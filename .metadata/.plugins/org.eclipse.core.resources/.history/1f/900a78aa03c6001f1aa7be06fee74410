In archive libATMEGA32.a:

TIMER2_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005c4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000975  00000000  00000000  000005f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.Global_PvCompareMatch 00000002  00000000  00000000  00000f6d  2**0
                  ALLOC
  6 .bss.Global_PvOverFlow 00000002  00000000  00000000  00000f6d  2**0
                  ALLOC
  7 .text.TIMER2_DutyCycle 00000048  00000000  00000000  00000f6d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.TIMER2_Delay 00000052  00000000  00000000  00000fb5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.TIMER2_voidInit 00000044  00000000  00000000  00001007  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.TIMER2_voiSetPreLoadValue 0000001c  00000000  00000000  0000104b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.TIMER2_voiSetCompareMatchValue 0000001c  00000000  00000000  00001067  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text.Timer2_Timer2OVFCallBackFunc 0000003a  00000000  00000000  00001083  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.Timer2_Timer2CTCCallBackFunc 0000003a  00000000  00000000  000010bd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.__vector_4 0000005a  00000000  00000000  000010f7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.__vector_5 0000005a  00000000  00000000  00001151  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.TIMER2_DutyCycle:

00000000 <TIMER2_DutyCycle>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_5(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER2_DutyCycle+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8b 83       	std	Y+3, r24	; 0x03
   e:	1a 82       	std	Y+2, r1	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8b 81       	ldd	r24, Y+3	; 0x03
  14:	88 2f       	mov	r24, r24
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	98 2f       	mov	r25, r24
  1a:	88 27       	eor	r24, r24
  1c:	9a 83       	std	Y+2, r25	; 0x02
  1e:	89 83       	std	Y+1, r24	; 0x01
  20:	89 81       	ldd	r24, Y+1	; 0x01
  22:	9a 81       	ldd	r25, Y+2	; 0x02
  24:	24 e6       	ldi	r18, 0x64	; 100
  26:	30 e0       	ldi	r19, 0x00	; 0
  28:	b9 01       	movw	r22, r18

	Global_PvOverFlow();
  2a:	0e 94 00 00 	call	0	; 0x0 <TIMER2_DutyCycle>
  2e:	cb 01       	movw	r24, r22
  30:	9a 83       	std	Y+2, r25	; 0x02
  32:	89 83       	std	Y+1, r24	; 0x01
}
  34:	e3 e4       	ldi	r30, 0x43	; 67
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	89 81       	ldd	r24, Y+1	; 0x01
  3a:	80 83       	st	Z, r24
  3c:	0f 90       	pop	r0
  3e:	0f 90       	pop	r0
  40:	0f 90       	pop	r0
  42:	cf 91       	pop	r28
  44:	df 91       	pop	r29
  46:	08 95       	ret

Disassembly of section .text.TIMER2_Delay:

00000000 <TIMER2_Delay>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_5(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER2_Delay+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <TIMER2_Delay+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9c 83       	std	Y+4, r25	; 0x04
   e:	8b 83       	std	Y+3, r24	; 0x03
  10:	1a 82       	std	Y+2, r1	; 0x02
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	00 c0       	rjmp	.+0      	; 0x16 <TIMER2_Delay+0x16>
  16:	e8 e5       	ldi	r30, 0x58	; 88
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	80 81       	ld	r24, Z
  1c:	80 78       	andi	r24, 0x80	; 128
  1e:	88 23       	and	r24, r24
  20:	01 f0       	breq	.+0      	; 0x22 <TIMER2_Delay+0x22>
  22:	e8 e5       	ldi	r30, 0x58	; 88
  24:	f0 e0       	ldi	r31, 0x00	; 0
  26:	80 81       	ld	r24, Z
  28:	80 68       	ori	r24, 0x80	; 128

	Global_PvOverFlow();
  2a:	80 83       	st	Z, r24
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	9a 81       	ldd	r25, Y+2	; 0x02
  30:	01 96       	adiw	r24, 0x01	; 1
  32:	9a 83       	std	Y+2, r25	; 0x02
}
  34:	89 83       	std	Y+1, r24	; 0x01
  36:	29 81       	ldd	r18, Y+1	; 0x01
  38:	3a 81       	ldd	r19, Y+2	; 0x02
  3a:	8b 81       	ldd	r24, Y+3	; 0x03
  3c:	9c 81       	ldd	r25, Y+4	; 0x04
  3e:	28 17       	cp	r18, r24
  40:	39 07       	cpc	r19, r25
  42:	00 f0       	brcs	.+0      	; 0x44 <TIMER2_Delay+0x44>
  44:	0f 90       	pop	r0
  46:	0f 90       	pop	r0
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
  4c:	cf 91       	pop	r28
  4e:	df 91       	pop	r29
  50:	08 95       	ret

Disassembly of section .text.TIMER2_voidInit:

00000000 <TIMER2_voidInit>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_5(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e5 e4       	ldi	r30, 0x45	; 69
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	88 7f       	andi	r24, 0xF8	; 248
  10:	84 60       	ori	r24, 0x04	; 4
  12:	80 83       	st	Z, r24
  14:	e5 e4       	ldi	r30, 0x45	; 69
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	8f 7b       	andi	r24, 0xBF	; 191
  1c:	80 83       	st	Z, r24
  1e:	e5 e4       	ldi	r30, 0x45	; 69
  20:	f0 e0       	ldi	r31, 0x00	; 0
  22:	80 81       	ld	r24, Z
  24:	88 60       	ori	r24, 0x08	; 8
  26:	80 83       	st	Z, r24
  28:	e5 e4       	ldi	r30, 0x45	; 69

	Global_PvOverFlow();
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	8f 7c       	andi	r24, 0xCF	; 207
  30:	80 61       	ori	r24, 0x10	; 16
  32:	80 83       	st	Z, r24
}
  34:	e9 e5       	ldi	r30, 0x59	; 89
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	80 81       	ld	r24, Z
  3a:	80 68       	ori	r24, 0x80	; 128
  3c:	80 83       	st	Z, r24
  3e:	cf 91       	pop	r28
  40:	df 91       	pop	r29
  42:	08 95       	ret

Disassembly of section .text.TIMER2_voiSetPreLoadValue:

00000000 <TIMER2_voiSetPreLoadValue>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_5(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	e4 e4       	ldi	r30, 0x44	; 68
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	80 83       	st	Z, r24
  14:	0f 90       	pop	r0
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.TIMER2_voiSetCompareMatchValue:

00000000 <TIMER2_voiSetCompareMatchValue>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	e3 e4       	ldi	r30, 0x43	; 67
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	80 83       	st	Z, r24
  14:	0f 90       	pop	r0
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.Timer2_Timer2OVFCallBackFunc:

00000000 <Timer2_Timer2OVFCallBackFunc>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer2_Timer2OVFCallBackFunc+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <Timer2_Timer2OVFCallBackFunc+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <Timer2_Timer2OVFCallBackFunc+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24

	Global_PvOverFlow();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.Timer2_Timer2CTCCallBackFunc:

00000000 <Timer2_Timer2CTCCallBackFunc>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_5(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer2_Timer2CTCCallBackFunc+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <Timer2_Timer2CTCCallBackFunc+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <Timer2_Timer2CTCCallBackFunc+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24

	Global_PvOverFlow();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.__vector_4:

00000000 <__vector_4>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_5(void){
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

	Global_PvOverFlow();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

Disassembly of section .text.__vector_5:

00000000 <__vector_5>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_5(void){
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

	Global_PvOverFlow();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

TIMER1_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000006f0  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000c6e  00000000  00000000  00000724  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.TIMER1_pvCallBackFunc_CTC_A 00000002  00000000  00000000  00001392  2**0
                  ALLOC
  6 .bss.TIMER1_pvCallBackFunc_CTC_B 00000002  00000000  00000000  00001392  2**0
                  ALLOC
  7 .bss.TIMER1_pvCallBackFunc_OV 00000002  00000000  00000000  00001392  2**0
                  ALLOC
  8 .bss.TIMER1_pvCallBackFunc_CaptEvnt 00000002  00000000  00000000  00001392  2**0
                  ALLOC
  9 .text.TIMER1_voidInit 00000048  00000000  00000000  00001392  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.TIMER1_voidSetChannelACompMatch 00000024  00000000  00000000  000013da  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.TIMER1_voidSetChannelBCompMatch 00000024  00000000  00000000  000013fe  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.TIMER1_voidSetICR 00000024  00000000  00000000  00001422  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.TIMER1_voidSetTimerValue 00000024  00000000  00000000  00001446  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.TIMER1_u16GetTimerValue 00000016  00000000  00000000  0000146a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.TIMER1_CTCASetCallBck 0000003a  00000000  00000000  00001480  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.TIMER1_CTCBSetCallBck 0000003a  00000000  00000000  000014ba  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.TIMER1_OVSetCallBck 0000003a  00000000  00000000  000014f4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text.TIMER1_CAPTURESetCallBck 0000003a  00000000  00000000  0000152e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text.__vector_6 0000005a  00000000  00000000  00001568  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text.__vector_7 0000005a  00000000  00000000  000015c2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text.__vector_8 0000005a  00000000  00000000  0000161c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text.__vector_9 0000005a  00000000  00000000  00001676  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.TIMER1_voidInit:

00000000 <TIMER1_voidInit>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	ee e4       	ldi	r30, 0x4E	; 78
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	88 7f       	andi	r24, 0xF8	; 248
  10:	82 60       	ori	r24, 0x02	; 2
  12:	80 83       	st	Z, r24
  14:	ef e4       	ldi	r30, 0x4F	; 79
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	8c 7f       	andi	r24, 0xFC	; 252
  1c:	82 60       	ori	r24, 0x02	; 2
  1e:	80 83       	st	Z, r24
  20:	ee e4       	ldi	r30, 0x4E	; 78
  22:	f0 e0       	ldi	r31, 0x00	; 0
  24:	80 81       	ld	r24, Z
  26:	88 61       	ori	r24, 0x18	; 24
  28:	80 83       	st	Z, r24
	TIMER1_pvCallBackFunc_OV();
  2a:	ef e4       	ldi	r30, 0x4F	; 79
  2c:	f0 e0       	ldi	r31, 0x00	; 0
  2e:	80 81       	ld	r24, Z
  30:	8f 73       	andi	r24, 0x3F	; 63
  32:	80 68       	ori	r24, 0x80	; 128
}
  34:	80 83       	st	Z, r24
  36:	ef e4       	ldi	r30, 0x4F	; 79
  38:	f0 e0       	ldi	r31, 0x00	; 0
  3a:	80 81       	ld	r24, Z
  3c:	8f 7c       	andi	r24, 0xCF	; 207
  3e:	80 62       	ori	r24, 0x20	; 32
  40:	80 83       	st	Z, r24
  42:	cf 91       	pop	r28
  44:	df 91       	pop	r29
  46:	08 95       	ret

Disassembly of section .text.TIMER1_voidSetChannelACompMatch:

00000000 <TIMER1_voidSetChannelACompMatch>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_voidSetChannelACompMatch+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	ea e4       	ldi	r30, 0x4A	; 74
  10:	f0 e0       	ldi	r31, 0x00	; 0
  12:	89 81       	ldd	r24, Y+1	; 0x01
  14:	9a 81       	ldd	r25, Y+2	; 0x02
  16:	91 83       	std	Z+1, r25	; 0x01
  18:	80 83       	st	Z, r24
  1a:	0f 90       	pop	r0
  1c:	0f 90       	pop	r0
  1e:	cf 91       	pop	r28
  20:	df 91       	pop	r29
  22:	08 95       	ret

Disassembly of section .text.TIMER1_voidSetChannelBCompMatch:

00000000 <TIMER1_voidSetChannelBCompMatch>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_voidSetChannelBCompMatch+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	e8 e4       	ldi	r30, 0x48	; 72
  10:	f0 e0       	ldi	r31, 0x00	; 0
  12:	89 81       	ldd	r24, Y+1	; 0x01
  14:	9a 81       	ldd	r25, Y+2	; 0x02
  16:	91 83       	std	Z+1, r25	; 0x01
  18:	80 83       	st	Z, r24
  1a:	0f 90       	pop	r0
  1c:	0f 90       	pop	r0
  1e:	cf 91       	pop	r28
  20:	df 91       	pop	r29
  22:	08 95       	ret

Disassembly of section .text.TIMER1_voidSetICR:

00000000 <TIMER1_voidSetICR>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_voidSetICR+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	e6 e4       	ldi	r30, 0x46	; 70
  10:	f0 e0       	ldi	r31, 0x00	; 0
  12:	89 81       	ldd	r24, Y+1	; 0x01
  14:	9a 81       	ldd	r25, Y+2	; 0x02
  16:	91 83       	std	Z+1, r25	; 0x01
  18:	80 83       	st	Z, r24
  1a:	0f 90       	pop	r0
  1c:	0f 90       	pop	r0
  1e:	cf 91       	pop	r28
  20:	df 91       	pop	r29
  22:	08 95       	ret

Disassembly of section .text.TIMER1_voidSetTimerValue:

00000000 <TIMER1_voidSetTimerValue>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_voidSetTimerValue+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	ec e4       	ldi	r30, 0x4C	; 76
  10:	f0 e0       	ldi	r31, 0x00	; 0
  12:	89 81       	ldd	r24, Y+1	; 0x01
  14:	9a 81       	ldd	r25, Y+2	; 0x02
  16:	91 83       	std	Z+1, r25	; 0x01
  18:	80 83       	st	Z, r24
  1a:	0f 90       	pop	r0
  1c:	0f 90       	pop	r0
  1e:	cf 91       	pop	r28
  20:	df 91       	pop	r29
  22:	08 95       	ret

Disassembly of section .text.TIMER1_u16GetTimerValue:

00000000 <TIMER1_u16GetTimerValue>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	ec e4       	ldi	r30, 0x4C	; 76
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	91 81       	ldd	r25, Z+1	; 0x01
  10:	cf 91       	pop	r28
  12:	df 91       	pop	r29
  14:	08 95       	ret

Disassembly of section .text.TIMER1_CTCASetCallBck:

00000000 <TIMER1_CTCASetCallBck>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_CTCASetCallBck+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <TIMER1_CTCASetCallBck+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <TIMER1_CTCASetCallBck+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24
	TIMER1_pvCallBackFunc_OV();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.TIMER1_CTCBSetCallBck:

00000000 <TIMER1_CTCBSetCallBck>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_CTCBSetCallBck+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <TIMER1_CTCBSetCallBck+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <TIMER1_CTCBSetCallBck+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24
	TIMER1_pvCallBackFunc_OV();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.TIMER1_OVSetCallBck:

00000000 <TIMER1_OVSetCallBck>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_OVSetCallBck+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <TIMER1_OVSetCallBck+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <TIMER1_OVSetCallBck+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24
	TIMER1_pvCallBackFunc_OV();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.TIMER1_CAPTURESetCallBck:

00000000 <TIMER1_CAPTURESetCallBck>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER1_CAPTURESetCallBck+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <TIMER1_CAPTURESetCallBck+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <TIMER1_CAPTURESetCallBck+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24
	TIMER1_pvCallBackFunc_OV();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.__vector_6:

00000000 <__vector_6>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	TIMER1_pvCallBackFunc_OV();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

Disassembly of section .text.__vector_7:

00000000 <__vector_7>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	TIMER1_pvCallBackFunc_OV();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

Disassembly of section .text.__vector_8:

00000000 <__vector_8>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	TIMER1_pvCallBackFunc_OV();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

Disassembly of section .text.__vector_9:

00000000 <__vector_9>:
	TIMER1_pvCallBackFunc_CTC_B();
}


void __vector_9 (void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	TIMER1_pvCallBackFunc_OV();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

TIMER0_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005b8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000920  00000000  00000000  000005ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.Global_PvCompareMatch 00000002  00000000  00000000  00000f0c  2**0
                  ALLOC
  6 .bss.Global_PvOverFlow 00000002  00000000  00000000  00000f0c  2**0
                  ALLOC
  7 .text.TIMER0_DutyCycle 00000048  00000000  00000000  00000f0c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.TIMER0_Delay 00000052  00000000  00000000  00000f54  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.TIMER0_voidInit 00000044  00000000  00000000  00000fa6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.TIMER0_voiSetPreLoadValue 0000001c  00000000  00000000  00000fea  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.TIMER0_voiSetCompareMatchValue 0000001c  00000000  00000000  00001006  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text.Timer0_Timer0OVFCallBackFunc 0000003a  00000000  00000000  00001022  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.Timer0_Timer0CTCCallBackFunc 0000003a  00000000  00000000  0000105c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.__vector_10 0000005a  00000000  00000000  00001096  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.__vector_11 0000005a  00000000  00000000  000010f0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.TIMER0_DutyCycle:

00000000 <TIMER0_DutyCycle>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_11(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER0_DutyCycle+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8b 83       	std	Y+3, r24	; 0x03
   e:	1a 82       	std	Y+2, r1	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8b 81       	ldd	r24, Y+3	; 0x03
  14:	88 2f       	mov	r24, r24
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	98 2f       	mov	r25, r24
  1a:	88 27       	eor	r24, r24
  1c:	9a 83       	std	Y+2, r25	; 0x02
  1e:	89 83       	std	Y+1, r24	; 0x01
  20:	89 81       	ldd	r24, Y+1	; 0x01
  22:	9a 81       	ldd	r25, Y+2	; 0x02
  24:	24 e6       	ldi	r18, 0x64	; 100
  26:	30 e0       	ldi	r19, 0x00	; 0
  28:	b9 01       	movw	r22, r18

	Global_PvOverFlow();
  2a:	0e 94 00 00 	call	0	; 0x0 <TIMER0_DutyCycle>
  2e:	cb 01       	movw	r24, r22
  30:	9a 83       	std	Y+2, r25	; 0x02
  32:	89 83       	std	Y+1, r24	; 0x01
}
  34:	ec e5       	ldi	r30, 0x5C	; 92
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	89 81       	ldd	r24, Y+1	; 0x01
  3a:	80 83       	st	Z, r24
  3c:	0f 90       	pop	r0
  3e:	0f 90       	pop	r0
  40:	0f 90       	pop	r0
  42:	cf 91       	pop	r28
  44:	df 91       	pop	r29
  46:	08 95       	ret

Disassembly of section .text.TIMER0_Delay:

00000000 <TIMER0_Delay>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_11(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TIMER0_Delay+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <TIMER0_Delay+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9c 83       	std	Y+4, r25	; 0x04
   e:	8b 83       	std	Y+3, r24	; 0x03
  10:	1a 82       	std	Y+2, r1	; 0x02
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	00 c0       	rjmp	.+0      	; 0x16 <TIMER0_Delay+0x16>
  16:	e8 e5       	ldi	r30, 0x58	; 88
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	80 81       	ld	r24, Z
  1c:	82 70       	andi	r24, 0x02	; 2
  1e:	88 23       	and	r24, r24
  20:	01 f0       	breq	.+0      	; 0x22 <TIMER0_Delay+0x22>
  22:	e8 e5       	ldi	r30, 0x58	; 88
  24:	f0 e0       	ldi	r31, 0x00	; 0
  26:	80 81       	ld	r24, Z
  28:	82 60       	ori	r24, 0x02	; 2

	Global_PvOverFlow();
  2a:	80 83       	st	Z, r24
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	9a 81       	ldd	r25, Y+2	; 0x02
  30:	01 96       	adiw	r24, 0x01	; 1
  32:	9a 83       	std	Y+2, r25	; 0x02
}
  34:	89 83       	std	Y+1, r24	; 0x01
  36:	29 81       	ldd	r18, Y+1	; 0x01
  38:	3a 81       	ldd	r19, Y+2	; 0x02
  3a:	8b 81       	ldd	r24, Y+3	; 0x03
  3c:	9c 81       	ldd	r25, Y+4	; 0x04
  3e:	28 17       	cp	r18, r24
  40:	39 07       	cpc	r19, r25
  42:	00 f0       	brcs	.+0      	; 0x44 <TIMER0_Delay+0x44>
  44:	0f 90       	pop	r0
  46:	0f 90       	pop	r0
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
  4c:	cf 91       	pop	r28
  4e:	df 91       	pop	r29
  50:	08 95       	ret

Disassembly of section .text.TIMER0_voidInit:

00000000 <TIMER0_voidInit>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_11(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e3 e5       	ldi	r30, 0x53	; 83
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	88 7f       	andi	r24, 0xF8	; 248
  10:	82 60       	ori	r24, 0x02	; 2
  12:	80 83       	st	Z, r24
  14:	e3 e5       	ldi	r30, 0x53	; 83
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	80 64       	ori	r24, 0x40	; 64
  1c:	80 83       	st	Z, r24
  1e:	e3 e5       	ldi	r30, 0x53	; 83
  20:	f0 e0       	ldi	r31, 0x00	; 0
  22:	80 81       	ld	r24, Z
  24:	88 60       	ori	r24, 0x08	; 8
  26:	80 83       	st	Z, r24
  28:	e3 e5       	ldi	r30, 0x53	; 83

	Global_PvOverFlow();
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	8f 7c       	andi	r24, 0xCF	; 207
  30:	80 62       	ori	r24, 0x20	; 32
  32:	80 83       	st	Z, r24
}
  34:	e9 e5       	ldi	r30, 0x59	; 89
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	80 81       	ld	r24, Z
  3a:	82 60       	ori	r24, 0x02	; 2
  3c:	80 83       	st	Z, r24
  3e:	cf 91       	pop	r28
  40:	df 91       	pop	r29
  42:	08 95       	ret

Disassembly of section .text.TIMER0_voiSetPreLoadValue:

00000000 <TIMER0_voiSetPreLoadValue>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_11(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	e2 e5       	ldi	r30, 0x52	; 82
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	80 83       	st	Z, r24
  14:	0f 90       	pop	r0
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.TIMER0_voiSetCompareMatchValue:

00000000 <TIMER0_voiSetCompareMatchValue>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	ec e5       	ldi	r30, 0x5C	; 92
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	80 83       	st	Z, r24
  14:	0f 90       	pop	r0
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.Timer0_Timer0OVFCallBackFunc:

00000000 <Timer0_Timer0OVFCallBackFunc>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer0_Timer0OVFCallBackFunc+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <Timer0_Timer0OVFCallBackFunc+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <Timer0_Timer0OVFCallBackFunc+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24

	Global_PvOverFlow();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.Timer0_Timer0CTCCallBackFunc:

00000000 <Timer0_Timer0CTCCallBackFunc>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_11(void){
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer0_Timer0CTCCallBackFunc+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <Timer0_Timer0CTCCallBackFunc+0x1a>
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <Timer0_Timer0CTCCallBackFunc+0x20>
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	9b 81       	ldd	r25, Y+3	; 0x03
  24:	90 93 00 00 	sts	0x0000, r25
  28:	80 93 00 00 	sts	0x0000, r24

	Global_PvOverFlow();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.__vector_10:

00000000 <__vector_10>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_11(void){
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

	Global_PvOverFlow();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

Disassembly of section .text.__vector_11:

00000000 <__vector_11>:

	Global_PvCompareMatch();
}

/*TIMER0 OVERFLOW*/
void __vector_11(void){
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

	Global_PvOverFlow();
  2a:	e0 91 00 00 	lds	r30, 0x0000
  2e:	f0 91 00 00 	lds	r31, 0x0000
  32:	09 95       	icall
}
  34:	cf 91       	pop	r28
  36:	df 91       	pop	r29
  38:	ff 91       	pop	r31
  3a:	ef 91       	pop	r30
  3c:	bf 91       	pop	r27
  3e:	af 91       	pop	r26
  40:	9f 91       	pop	r25
  42:	8f 91       	pop	r24
  44:	7f 91       	pop	r23
  46:	6f 91       	pop	r22
  48:	5f 91       	pop	r21
  4a:	4f 91       	pop	r20
  4c:	3f 91       	pop	r19
  4e:	2f 91       	pop	r18
  50:	0f 90       	pop	r0
  52:	0f be       	out	0x3f, r0	; 63
  54:	0f 90       	pop	r0
  56:	1f 90       	pop	r1
  58:	18 95       	reti

PORT_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000204  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000034e  00000000  00000000  00000238  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.PORT_voidInit 00000040  00000000  00000000  00000586  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text.PORT_voidInit:

00000000 <PORT_voidInit>:
#include"../inc/PORT_config.h"



void PORT_voidInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62

DDRA=PORTA_DIR;
   8:	ea e3       	ldi	r30, 0x3A	; 58
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	8f ef       	ldi	r24, 0xFF	; 255
   e:	80 83       	st	Z, r24
DDRB=PORTB_DIR;
  10:	e7 e3       	ldi	r30, 0x37	; 55
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	10 82       	st	Z, r1
DDRC=PORTC_DIR;
  16:	e4 e3       	ldi	r30, 0x34	; 52
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	10 82       	st	Z, r1
DDRD=PORTD_DIR;
  1c:	e1 e3       	ldi	r30, 0x31	; 49
  1e:	f0 e0       	ldi	r31, 0x00	; 0
  20:	10 82       	st	Z, r1

PORTA=PORTA_INIT_VALUE;
  22:	eb e3       	ldi	r30, 0x3B	; 59
  24:	f0 e0       	ldi	r31, 0x00	; 0
  26:	10 82       	st	Z, r1
PORTB=PORTB_INIT_VALUE;
  28:	e8 e3       	ldi	r30, 0x38	; 56
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	10 82       	st	Z, r1
PORTC=PORTC_INIT_VALUE;
  2e:	e5 e3       	ldi	r30, 0x35	; 53
  30:	f0 e0       	ldi	r31, 0x00	; 0
  32:	10 82       	st	Z, r1
PORTD=PORTD_INIT_VALUE;
  34:	e2 e3       	ldi	r30, 0x32	; 50
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	10 82       	st	Z, r1
}
  3a:	cf 91       	pop	r28
  3c:	df 91       	pop	r29
  3e:	08 95       	ret

GIE_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000001e0  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000035b  00000000  00000000  00000214  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.GIE_Enable 0000001c  00000000  00000000  0000056f  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.GIE_Disable 0000001c  00000000  00000000  0000058b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text.GIE_Enable:

00000000 <GIE_Enable>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/GIE_interface.h"
#include "../inc/GIE_register.h"

void GIE_Enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
SET_BIT(SREG,SREG_I);
   8:	af e5       	ldi	r26, 0x5F	; 95
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	ef e5       	ldi	r30, 0x5F	; 95
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	80 68       	ori	r24, 0x80	; 128
  14:	8c 93       	st	X, r24

}
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.GIE_Disable:

00000000 <GIE_Disable>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/GIE_interface.h"
#include "../inc/GIE_register.h"

void GIE_Enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
SET_BIT(SREG,SREG_I);
   8:	af e5       	ldi	r26, 0x5F	; 95
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	ef e5       	ldi	r30, 0x5F	; 95
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	8f 77       	andi	r24, 0x7F	; 127
  14:	8c 93       	st	X, r24

}
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

EXTI_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000774  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000060d  00000000  00000000  000007a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.Global_EXTI_pvInt0Func 00000002  00000000  00000000  00000db5  2**0
                  ALLOC
  6 .bss.Global_EXTI_pvInt1Func 00000002  00000000  00000000  00000db5  2**0
                  ALLOC
  7 .bss.Global_EXTI_pvInt2Func 00000002  00000000  00000000  00000db5  2**0
                  ALLOC
  8 .text.EXTI_voidInt0Init 00000038  00000000  00000000  00000db5  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.EXTI_voidInt1Init 0000002a  00000000  00000000  00000ded  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.EXTI_voidInt2Init 0000001c  00000000  00000000  00000e17  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.EXTI_u8IntSetSenseControl 00000206  00000000  00000000  00000e33  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.EXTI_u8IntEnable 0000007c  00000000  00000000  00001039  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.EXTI_u8IntDisable 0000007c  00000000  00000000  000010b5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.EXTI_u8Int0SetCallBack 0000003a  00000000  00000000  00001131  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.EXTI_u8Int1SetCallBack 0000003a  00000000  00000000  0000116b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.EXTI_u8Int2SetCallBack 0000003a  00000000  00000000  000011a5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.__vector_1 00000066  00000000  00000000  000011df  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text.__vector_2 00000066  00000000  00000000  00001245  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text.__vector_3 00000066  00000000  00000000  000012ab  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.EXTI_voidInt0Init:

00000000 <EXTI_voidInt0Init>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a5 e5       	ldi	r26, 0x55	; 85
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e5 e5       	ldi	r30, 0x55	; 85
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	81 60       	ori	r24, 0x01	; 1
  14:	8c 93       	st	X, r24
  16:	a5 e5       	ldi	r26, 0x55	; 85
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	e5 e5       	ldi	r30, 0x55	; 85
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	8d 7f       	andi	r24, 0xFD	; 253
  22:	8c 93       	st	X, r24
  24:	ab e5       	ldi	r26, 0x5B	; 91
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	eb e5       	ldi	r30, 0x5B	; 91

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	80 64       	ori	r24, 0x40	; 64
  30:	8c 93       	st	X, r24
  32:	cf 91       	pop	r28
  34:	df 91       	pop	r29
		{
		Global_EXTI_pvInt2Func();
  36:	08 95       	ret

Disassembly of section .text.EXTI_voidInt1Init:

00000000 <EXTI_voidInt1Init>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a5 e5       	ldi	r26, 0x55	; 85
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e5 e5       	ldi	r30, 0x55	; 85
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	84 60       	ori	r24, 0x04	; 4
  14:	8c 93       	st	X, r24
  16:	a5 e5       	ldi	r26, 0x55	; 85
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	e5 e5       	ldi	r30, 0x55	; 85
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	87 7f       	andi	r24, 0xF7	; 247
  22:	8c 93       	st	X, r24
  24:	cf 91       	pop	r28
  26:	df 91       	pop	r29
  28:	08 95       	ret

Disassembly of section .text.EXTI_voidInt2Init:

00000000 <EXTI_voidInt2Init>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a4 e5       	ldi	r26, 0x54	; 84
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e4 e5       	ldi	r30, 0x54	; 84
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	8f 7b       	andi	r24, 0xBF	; 191
  14:	8c 93       	st	X, r24
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.EXTI_u8IntSetSenseControl:

00000000 <EXTI_u8IntSetSenseControl>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	29 97       	sbiw	r28, 0x09	; 9
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	19 82       	std	Y+1, r1	; 0x01
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	01 f0       	breq	.+0      	; 0x20 <EXTI_u8IntSetSenseControl+0x20>
  20:	00 c0       	rjmp	.+0      	; 0x22 <EXTI_u8IntSetSenseControl+0x22>
  22:	8b 81       	ldd	r24, Y+3	; 0x03
  24:	28 2f       	mov	r18, r24
  26:	30 e0       	ldi	r19, 0x00	; 0
  28:	39 87       	std	Y+9, r19	; 0x09

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	28 87       	std	Y+8, r18	; 0x08
  2c:	88 85       	ldd	r24, Y+8	; 0x08
  2e:	99 85       	ldd	r25, Y+9	; 0x09
  30:	81 30       	cpi	r24, 0x01	; 1
  32:	91 05       	cpc	r25, r1
  34:	01 f0       	breq	.+0      	; 0x36 <EXTI_u8IntSetSenseControl+0x36>
		{
		Global_EXTI_pvInt2Func();
  36:	28 85       	ldd	r18, Y+8	; 0x08
  38:	39 85       	ldd	r19, Y+9	; 0x09
  3a:	22 30       	cpi	r18, 0x02	; 2
  3c:	31 05       	cpc	r19, r1
  3e:	04 f4       	brge	.+0      	; 0x40 <EXTI_u8IntSetSenseControl+0x40>
		{
			//do nothing

		}

}
  40:	88 85       	ldd	r24, Y+8	; 0x08
  42:	99 85       	ldd	r25, Y+9	; 0x09
  44:	00 97       	sbiw	r24, 0x00	; 0
  46:	01 f0       	breq	.+0      	; 0x48 <EXTI_u8IntSetSenseControl+0x48>
  48:	00 c0       	rjmp	.+0      	; 0x4a <EXTI_u8IntSetSenseControl+0x4a>
  4a:	28 85       	ldd	r18, Y+8	; 0x08
  4c:	39 85       	ldd	r19, Y+9	; 0x09
  4e:	22 30       	cpi	r18, 0x02	; 2
  50:	31 05       	cpc	r19, r1
  52:	01 f0       	breq	.+0      	; 0x54 <EXTI_u8IntSetSenseControl+0x54>
  54:	88 85       	ldd	r24, Y+8	; 0x08
  56:	99 85       	ldd	r25, Y+9	; 0x09
  58:	83 30       	cpi	r24, 0x03	; 3
  5a:	91 05       	cpc	r25, r1
  5c:	01 f0       	breq	.+0      	; 0x5e <EXTI_u8IntSetSenseControl+0x5e>
  5e:	00 c0       	rjmp	.+0      	; 0x60 <EXTI_u8IntSetSenseControl+0x60>
  60:	a5 e5       	ldi	r26, 0x55	; 85
  62:	b0 e0       	ldi	r27, 0x00	; 0
  64:	e5 e5       	ldi	r30, 0x55	; 85
  66:	f0 e0       	ldi	r31, 0x00	; 0
  68:	80 81       	ld	r24, Z
  6a:	8e 7f       	andi	r24, 0xFE	; 254
  6c:	8c 93       	st	X, r24
  6e:	a5 e5       	ldi	r26, 0x55	; 85
  70:	b0 e0       	ldi	r27, 0x00	; 0
  72:	e5 e5       	ldi	r30, 0x55	; 85
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	80 81       	ld	r24, Z
  78:	8d 7f       	andi	r24, 0xFD	; 253
  7a:	8c 93       	st	X, r24
  7c:	00 c0       	rjmp	.+0      	; 0x7e <EXTI_u8IntSetSenseControl+0x7e>
  7e:	a5 e5       	ldi	r26, 0x55	; 85
  80:	b0 e0       	ldi	r27, 0x00	; 0
  82:	e5 e5       	ldi	r30, 0x55	; 85
  84:	f0 e0       	ldi	r31, 0x00	; 0
  86:	80 81       	ld	r24, Z
  88:	81 60       	ori	r24, 0x01	; 1
  8a:	8c 93       	st	X, r24
  8c:	a5 e5       	ldi	r26, 0x55	; 85
  8e:	b0 e0       	ldi	r27, 0x00	; 0
  90:	e5 e5       	ldi	r30, 0x55	; 85
  92:	f0 e0       	ldi	r31, 0x00	; 0
  94:	80 81       	ld	r24, Z
  96:	8d 7f       	andi	r24, 0xFD	; 253
  98:	8c 93       	st	X, r24
  9a:	00 c0       	rjmp	.+0      	; 0x9c <EXTI_u8IntSetSenseControl+0x9c>
  9c:	a5 e5       	ldi	r26, 0x55	; 85
  9e:	b0 e0       	ldi	r27, 0x00	; 0
  a0:	e5 e5       	ldi	r30, 0x55	; 85
  a2:	f0 e0       	ldi	r31, 0x00	; 0
  a4:	80 81       	ld	r24, Z
  a6:	8e 7f       	andi	r24, 0xFE	; 254
  a8:	8c 93       	st	X, r24
  aa:	a5 e5       	ldi	r26, 0x55	; 85
  ac:	b0 e0       	ldi	r27, 0x00	; 0
  ae:	e5 e5       	ldi	r30, 0x55	; 85
  b0:	f0 e0       	ldi	r31, 0x00	; 0
  b2:	80 81       	ld	r24, Z
  b4:	82 60       	ori	r24, 0x02	; 2
  b6:	8c 93       	st	X, r24
  b8:	00 c0       	rjmp	.+0      	; 0xba <EXTI_u8IntSetSenseControl+0xba>
  ba:	a5 e5       	ldi	r26, 0x55	; 85
  bc:	b0 e0       	ldi	r27, 0x00	; 0
  be:	e5 e5       	ldi	r30, 0x55	; 85
  c0:	f0 e0       	ldi	r31, 0x00	; 0
  c2:	80 81       	ld	r24, Z
  c4:	81 60       	ori	r24, 0x01	; 1
  c6:	8c 93       	st	X, r24
  c8:	a5 e5       	ldi	r26, 0x55	; 85
  ca:	b0 e0       	ldi	r27, 0x00	; 0
  cc:	e5 e5       	ldi	r30, 0x55	; 85
  ce:	f0 e0       	ldi	r31, 0x00	; 0
  d0:	80 81       	ld	r24, Z
  d2:	82 60       	ori	r24, 0x02	; 2
  d4:	8c 93       	st	X, r24
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <EXTI_u8IntSetSenseControl+0xd8>
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	89 83       	std	Y+1, r24	; 0x01
  dc:	00 c0       	rjmp	.+0      	; 0xde <EXTI_u8IntSetSenseControl+0xde>
  de:	8a 81       	ldd	r24, Y+2	; 0x02
  e0:	82 30       	cpi	r24, 0x02	; 2
  e2:	01 f0       	breq	.+0      	; 0xe4 <EXTI_u8IntSetSenseControl+0xe4>
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <EXTI_u8IntSetSenseControl+0xe6>
  e6:	8b 81       	ldd	r24, Y+3	; 0x03
  e8:	28 2f       	mov	r18, r24
  ea:	30 e0       	ldi	r19, 0x00	; 0
  ec:	3f 83       	std	Y+7, r19	; 0x07
  ee:	2e 83       	std	Y+6, r18	; 0x06
  f0:	8e 81       	ldd	r24, Y+6	; 0x06
  f2:	9f 81       	ldd	r25, Y+7	; 0x07
  f4:	81 30       	cpi	r24, 0x01	; 1
  f6:	91 05       	cpc	r25, r1
  f8:	01 f0       	breq	.+0      	; 0xfa <EXTI_u8IntSetSenseControl+0xfa>
  fa:	2e 81       	ldd	r18, Y+6	; 0x06
  fc:	3f 81       	ldd	r19, Y+7	; 0x07
  fe:	22 30       	cpi	r18, 0x02	; 2
 100:	31 05       	cpc	r19, r1
 102:	04 f4       	brge	.+0      	; 0x104 <EXTI_u8IntSetSenseControl+0x104>
 104:	8e 81       	ldd	r24, Y+6	; 0x06
 106:	9f 81       	ldd	r25, Y+7	; 0x07
 108:	00 97       	sbiw	r24, 0x00	; 0
 10a:	01 f0       	breq	.+0      	; 0x10c <EXTI_u8IntSetSenseControl+0x10c>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <EXTI_u8IntSetSenseControl+0x10e>
 10e:	2e 81       	ldd	r18, Y+6	; 0x06
 110:	3f 81       	ldd	r19, Y+7	; 0x07
 112:	22 30       	cpi	r18, 0x02	; 2
 114:	31 05       	cpc	r19, r1
 116:	01 f0       	breq	.+0      	; 0x118 <EXTI_u8IntSetSenseControl+0x118>
 118:	8e 81       	ldd	r24, Y+6	; 0x06
 11a:	9f 81       	ldd	r25, Y+7	; 0x07
 11c:	83 30       	cpi	r24, 0x03	; 3
 11e:	91 05       	cpc	r25, r1
 120:	01 f0       	breq	.+0      	; 0x122 <EXTI_u8IntSetSenseControl+0x122>
 122:	00 c0       	rjmp	.+0      	; 0x124 <EXTI_u8IntSetSenseControl+0x124>
 124:	a5 e5       	ldi	r26, 0x55	; 85
 126:	b0 e0       	ldi	r27, 0x00	; 0
 128:	e5 e5       	ldi	r30, 0x55	; 85
 12a:	f0 e0       	ldi	r31, 0x00	; 0
 12c:	80 81       	ld	r24, Z
 12e:	8b 7f       	andi	r24, 0xFB	; 251
 130:	8c 93       	st	X, r24
 132:	a5 e5       	ldi	r26, 0x55	; 85
 134:	b0 e0       	ldi	r27, 0x00	; 0
 136:	e5 e5       	ldi	r30, 0x55	; 85
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	80 81       	ld	r24, Z
 13c:	87 7f       	andi	r24, 0xF7	; 247
 13e:	8c 93       	st	X, r24
 140:	00 c0       	rjmp	.+0      	; 0x142 <EXTI_u8IntSetSenseControl+0x142>
 142:	a5 e5       	ldi	r26, 0x55	; 85
 144:	b0 e0       	ldi	r27, 0x00	; 0
 146:	e5 e5       	ldi	r30, 0x55	; 85
 148:	f0 e0       	ldi	r31, 0x00	; 0
 14a:	80 81       	ld	r24, Z
 14c:	84 60       	ori	r24, 0x04	; 4
 14e:	8c 93       	st	X, r24
 150:	a5 e5       	ldi	r26, 0x55	; 85
 152:	b0 e0       	ldi	r27, 0x00	; 0
 154:	e5 e5       	ldi	r30, 0x55	; 85
 156:	f0 e0       	ldi	r31, 0x00	; 0
 158:	80 81       	ld	r24, Z
 15a:	87 7f       	andi	r24, 0xF7	; 247
 15c:	8c 93       	st	X, r24
 15e:	00 c0       	rjmp	.+0      	; 0x160 <EXTI_u8IntSetSenseControl+0x160>
 160:	a5 e5       	ldi	r26, 0x55	; 85
 162:	b0 e0       	ldi	r27, 0x00	; 0
 164:	e5 e5       	ldi	r30, 0x55	; 85
 166:	f0 e0       	ldi	r31, 0x00	; 0
 168:	80 81       	ld	r24, Z
 16a:	8b 7f       	andi	r24, 0xFB	; 251
 16c:	8c 93       	st	X, r24
 16e:	a5 e5       	ldi	r26, 0x55	; 85
 170:	b0 e0       	ldi	r27, 0x00	; 0
 172:	e5 e5       	ldi	r30, 0x55	; 85
 174:	f0 e0       	ldi	r31, 0x00	; 0
 176:	80 81       	ld	r24, Z
 178:	88 60       	ori	r24, 0x08	; 8
 17a:	8c 93       	st	X, r24
 17c:	00 c0       	rjmp	.+0      	; 0x17e <EXTI_u8IntSetSenseControl+0x17e>
 17e:	a5 e5       	ldi	r26, 0x55	; 85
 180:	b0 e0       	ldi	r27, 0x00	; 0
 182:	e5 e5       	ldi	r30, 0x55	; 85
 184:	f0 e0       	ldi	r31, 0x00	; 0
 186:	80 81       	ld	r24, Z
 188:	84 60       	ori	r24, 0x04	; 4
 18a:	8c 93       	st	X, r24
 18c:	a5 e5       	ldi	r26, 0x55	; 85
 18e:	b0 e0       	ldi	r27, 0x00	; 0
 190:	e5 e5       	ldi	r30, 0x55	; 85
 192:	f0 e0       	ldi	r31, 0x00	; 0
 194:	80 81       	ld	r24, Z
 196:	88 60       	ori	r24, 0x08	; 8
 198:	8c 93       	st	X, r24
 19a:	00 c0       	rjmp	.+0      	; 0x19c <EXTI_u8IntSetSenseControl+0x19c>
 19c:	81 e0       	ldi	r24, 0x01	; 1
 19e:	89 83       	std	Y+1, r24	; 0x01
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <EXTI_u8IntSetSenseControl+0x1a2>
 1a2:	8a 81       	ldd	r24, Y+2	; 0x02
 1a4:	83 30       	cpi	r24, 0x03	; 3
 1a6:	01 f4       	brne	.+0      	; 0x1a8 <EXTI_u8IntSetSenseControl+0x1a8>
 1a8:	8b 81       	ldd	r24, Y+3	; 0x03
 1aa:	28 2f       	mov	r18, r24
 1ac:	30 e0       	ldi	r19, 0x00	; 0
 1ae:	3d 83       	std	Y+5, r19	; 0x05
 1b0:	2c 83       	std	Y+4, r18	; 0x04
 1b2:	8c 81       	ldd	r24, Y+4	; 0x04
 1b4:	9d 81       	ldd	r25, Y+5	; 0x05
 1b6:	82 30       	cpi	r24, 0x02	; 2
 1b8:	91 05       	cpc	r25, r1
 1ba:	01 f0       	breq	.+0      	; 0x1bc <EXTI_u8IntSetSenseControl+0x1bc>
 1bc:	2c 81       	ldd	r18, Y+4	; 0x04
 1be:	3d 81       	ldd	r19, Y+5	; 0x05
 1c0:	23 30       	cpi	r18, 0x03	; 3
 1c2:	31 05       	cpc	r19, r1
 1c4:	01 f0       	breq	.+0      	; 0x1c6 <EXTI_u8IntSetSenseControl+0x1c6>
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <EXTI_u8IntSetSenseControl+0x1c8>
 1c8:	a4 e5       	ldi	r26, 0x54	; 84
 1ca:	b0 e0       	ldi	r27, 0x00	; 0
 1cc:	e4 e5       	ldi	r30, 0x54	; 84
 1ce:	f0 e0       	ldi	r31, 0x00	; 0
 1d0:	80 81       	ld	r24, Z
 1d2:	8f 7b       	andi	r24, 0xBF	; 191
 1d4:	8c 93       	st	X, r24
 1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <EXTI_u8IntSetSenseControl+0x1d8>
 1d8:	a4 e5       	ldi	r26, 0x54	; 84
 1da:	b0 e0       	ldi	r27, 0x00	; 0
 1dc:	e4 e5       	ldi	r30, 0x54	; 84
 1de:	f0 e0       	ldi	r31, 0x00	; 0
 1e0:	80 81       	ld	r24, Z
 1e2:	80 64       	ori	r24, 0x40	; 64
 1e4:	8c 93       	st	X, r24
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <EXTI_u8IntSetSenseControl+0x1e8>
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	89 83       	std	Y+1, r24	; 0x01
 1ec:	00 c0       	rjmp	.+0      	; 0x1ee <EXTI_u8IntSetSenseControl+0x1ee>
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	89 83       	std	Y+1, r24	; 0x01
 1f2:	89 81       	ldd	r24, Y+1	; 0x01
 1f4:	29 96       	adiw	r28, 0x09	; 9
 1f6:	0f b6       	in	r0, 0x3f	; 63
 1f8:	f8 94       	cli
 1fa:	de bf       	out	0x3e, r29	; 62
 1fc:	0f be       	out	0x3f, r0	; 63
 1fe:	cd bf       	out	0x3d, r28	; 61
 200:	cf 91       	pop	r28
 202:	df 91       	pop	r29
 204:	08 95       	ret

Disassembly of section .text.EXTI_u8IntEnable:

00000000 <EXTI_u8IntEnable>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <EXTI_u8IntEnable+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <EXTI_u8IntEnable+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
   e:	19 82       	std	Y+1, r1	; 0x01
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	28 2f       	mov	r18, r24
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	82 30       	cpi	r24, 0x02	; 2
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <EXTI_u8IntEnable+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	23 30       	cpi	r18, 0x03	; 3

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	31 05       	cpc	r19, r1
  2c:	01 f0       	breq	.+0      	; 0x2e <EXTI_u8IntEnable+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	81 30       	cpi	r24, 0x01	; 1
  34:	91 05       	cpc	r25, r1
		{
		Global_EXTI_pvInt2Func();
  36:	01 f4       	brne	.+0      	; 0x38 <EXTI_u8IntEnable+0x38>
  38:	ab e5       	ldi	r26, 0x5B	; 91
  3a:	b0 e0       	ldi	r27, 0x00	; 0
  3c:	eb e5       	ldi	r30, 0x5B	; 91
  3e:	f0 e0       	ldi	r31, 0x00	; 0
		{
			//do nothing

		}

}
  40:	80 81       	ld	r24, Z
  42:	80 64       	ori	r24, 0x40	; 64
  44:	8c 93       	st	X, r24
  46:	00 c0       	rjmp	.+0      	; 0x48 <EXTI_u8IntEnable+0x48>
  48:	ab e5       	ldi	r26, 0x5B	; 91
  4a:	b0 e0       	ldi	r27, 0x00	; 0
  4c:	eb e5       	ldi	r30, 0x5B	; 91
  4e:	f0 e0       	ldi	r31, 0x00	; 0
  50:	80 81       	ld	r24, Z
  52:	80 68       	ori	r24, 0x80	; 128
  54:	8c 93       	st	X, r24
  56:	00 c0       	rjmp	.+0      	; 0x58 <EXTI_u8IntEnable+0x58>
  58:	ab e5       	ldi	r26, 0x5B	; 91
  5a:	b0 e0       	ldi	r27, 0x00	; 0
  5c:	eb e5       	ldi	r30, 0x5B	; 91
  5e:	f0 e0       	ldi	r31, 0x00	; 0
  60:	80 81       	ld	r24, Z
  62:	80 62       	ori	r24, 0x20	; 32
  64:	8c 93       	st	X, r24
  66:	00 c0       	rjmp	.+0      	; 0x68 <EXTI_u8IntEnable+0x68>
  68:	81 e0       	ldi	r24, 0x01	; 1
  6a:	89 83       	std	Y+1, r24	; 0x01
  6c:	89 81       	ldd	r24, Y+1	; 0x01
  6e:	0f 90       	pop	r0
  70:	0f 90       	pop	r0
  72:	0f 90       	pop	r0
  74:	0f 90       	pop	r0
  76:	cf 91       	pop	r28
  78:	df 91       	pop	r29
  7a:	08 95       	ret

Disassembly of section .text.EXTI_u8IntDisable:

00000000 <EXTI_u8IntDisable>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <EXTI_u8IntDisable+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <EXTI_u8IntDisable+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
   e:	19 82       	std	Y+1, r1	; 0x01
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	28 2f       	mov	r18, r24
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	82 30       	cpi	r24, 0x02	; 2
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <EXTI_u8IntDisable+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	23 30       	cpi	r18, 0x03	; 3

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	31 05       	cpc	r19, r1
  2c:	01 f0       	breq	.+0      	; 0x2e <EXTI_u8IntDisable+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	81 30       	cpi	r24, 0x01	; 1
  34:	91 05       	cpc	r25, r1
		{
		Global_EXTI_pvInt2Func();
  36:	01 f4       	brne	.+0      	; 0x38 <EXTI_u8IntDisable+0x38>
  38:	ab e5       	ldi	r26, 0x5B	; 91
  3a:	b0 e0       	ldi	r27, 0x00	; 0
  3c:	eb e5       	ldi	r30, 0x5B	; 91
  3e:	f0 e0       	ldi	r31, 0x00	; 0
		{
			//do nothing

		}

}
  40:	80 81       	ld	r24, Z
  42:	8f 7b       	andi	r24, 0xBF	; 191
  44:	8c 93       	st	X, r24
  46:	00 c0       	rjmp	.+0      	; 0x48 <EXTI_u8IntDisable+0x48>
  48:	ab e5       	ldi	r26, 0x5B	; 91
  4a:	b0 e0       	ldi	r27, 0x00	; 0
  4c:	eb e5       	ldi	r30, 0x5B	; 91
  4e:	f0 e0       	ldi	r31, 0x00	; 0
  50:	80 81       	ld	r24, Z
  52:	8f 77       	andi	r24, 0x7F	; 127
  54:	8c 93       	st	X, r24
  56:	00 c0       	rjmp	.+0      	; 0x58 <EXTI_u8IntDisable+0x58>
  58:	ab e5       	ldi	r26, 0x5B	; 91
  5a:	b0 e0       	ldi	r27, 0x00	; 0
  5c:	eb e5       	ldi	r30, 0x5B	; 91
  5e:	f0 e0       	ldi	r31, 0x00	; 0
  60:	80 81       	ld	r24, Z
  62:	8f 7d       	andi	r24, 0xDF	; 223
  64:	8c 93       	st	X, r24
  66:	00 c0       	rjmp	.+0      	; 0x68 <EXTI_u8IntDisable+0x68>
  68:	81 e0       	ldi	r24, 0x01	; 1
  6a:	89 83       	std	Y+1, r24	; 0x01
  6c:	89 81       	ldd	r24, Y+1	; 0x01
  6e:	0f 90       	pop	r0
  70:	0f 90       	pop	r0
  72:	0f 90       	pop	r0
  74:	0f 90       	pop	r0
  76:	cf 91       	pop	r28
  78:	df 91       	pop	r29
  7a:	08 95       	ret

Disassembly of section .text.EXTI_u8Int0SetCallBack:

00000000 <EXTI_u8Int0SetCallBack>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <EXTI_u8Int0SetCallBack+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f0       	breq	.+0      	; 0x1a <EXTI_u8Int0SetCallBack+0x1a>
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	9b 81       	ldd	r25, Y+3	; 0x03
  1e:	90 93 00 00 	sts	0x0000, r25
  22:	80 93 00 00 	sts	0x0000, r24
  26:	00 c0       	rjmp	.+0      	; 0x28 <EXTI_u8Int0SetCallBack+0x28>
  28:	82 e0       	ldi	r24, 0x02	; 2

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	89 83       	std	Y+1, r24	; 0x01
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
  34:	cf 91       	pop	r28
		{
		Global_EXTI_pvInt2Func();
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.EXTI_u8Int1SetCallBack:

00000000 <EXTI_u8Int1SetCallBack>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <EXTI_u8Int1SetCallBack+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f0       	breq	.+0      	; 0x1a <EXTI_u8Int1SetCallBack+0x1a>
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	9b 81       	ldd	r25, Y+3	; 0x03
  1e:	90 93 00 00 	sts	0x0000, r25
  22:	80 93 00 00 	sts	0x0000, r24
  26:	00 c0       	rjmp	.+0      	; 0x28 <EXTI_u8Int1SetCallBack+0x28>
  28:	82 e0       	ldi	r24, 0x02	; 2

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	89 83       	std	Y+1, r24	; 0x01
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
  34:	cf 91       	pop	r28
		{
		Global_EXTI_pvInt2Func();
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.EXTI_u8Int2SetCallBack:

00000000 <EXTI_u8Int2SetCallBack>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <EXTI_u8Int2SetCallBack+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	9b 81       	ldd	r25, Y+3	; 0x03
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f0       	breq	.+0      	; 0x1a <EXTI_u8Int2SetCallBack+0x1a>
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	9b 81       	ldd	r25, Y+3	; 0x03
  1e:	90 93 00 00 	sts	0x0000, r25
  22:	80 93 00 00 	sts	0x0000, r24
  26:	00 c0       	rjmp	.+0      	; 0x28 <EXTI_u8Int2SetCallBack+0x28>
  28:	82 e0       	ldi	r24, 0x02	; 2

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	89 83       	std	Y+1, r24	; 0x01
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
  34:	cf 91       	pop	r28
		{
		Global_EXTI_pvInt2Func();
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.__vector_1:

00000000 <__vector_1>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_1+0x36>
		{
		Global_EXTI_pvInt2Func();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
		{
			//do nothing

		}

}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_2:

00000000 <__vector_2>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_2+0x36>
		{
		Global_EXTI_pvInt2Func();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
		{
			//do nothing

		}

}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_3:

00000000 <__vector_3>:


/*ISR of INT2*/

void __vector_3(void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

	if(Global_EXTI_pvInt2Func!=NULL)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_3+0x36>
		{
		Global_EXTI_pvInt2Func();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
		{
			//do nothing

		}

}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

DIO_Program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000007d4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000006e4  00000000  00000000  00000808  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.DIO_SetPortVal 00000096  00000000  00000000  00000eec  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.DIO_SetPinVal 0000021c  00000000  00000000  00000f82  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.DIO_SetPortDir 00000096  00000000  00000000  0000119e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.DIO_SetPinDir 0000021c  00000000  00000000  00001234  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.DIO_GetPinVal 0000012a  00000000  00000000  00001450  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.DIO_GetPortVal 000000aa  00000000  00000000  0000157a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.DIO_SetPortVal:

00000000 <DIO_SetPortVal>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/DIO_interface.h"
#include  "../inc/DIO_private.h"
#include "../inc/DIO_register.h"

status_t DIO_SetPortVal(Port_t Copy_Port, u8 Copy_u8Value) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_SetPortVal+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_SetPortVal+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
	status_t Local_u8ErrorState = DIO_ok;
  12:	19 82       	std	Y+1, r1	; 0x01
	if ((Copy_Port > DIO_PORTD) || (Copy_Port < DIO_PORTA)) {
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	84 30       	cpi	r24, 0x04	; 4
  18:	00 f0       	brcs	.+0      	; 0x1a <DIO_SetPortVal+0x1a>
		Local_u8ErrorState = DIO_SetErr;
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <DIO_SetPortVal+0x20>
	} else {
		switch (Copy_Port) {
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	28 2f       	mov	r18, r24
  24:	30 e0       	ldi	r19, 0x00	; 0
  26:	3d 83       	std	Y+5, r19	; 0x05
  28:	2c 83       	std	Y+4, r18	; 0x04
  2a:	8c 81       	ldd	r24, Y+4	; 0x04
  2c:	9d 81       	ldd	r25, Y+5	; 0x05
  2e:	81 30       	cpi	r24, 0x01	; 1
  30:	91 05       	cpc	r25, r1
  32:	01 f0       	breq	.+0      	; 0x34 <DIO_SetPortVal+0x34>
  34:	2c 81       	ldd	r18, Y+4	; 0x04
  36:	3d 81       	ldd	r19, Y+5	; 0x05
  38:	22 30       	cpi	r18, 0x02	; 2
  3a:	31 05       	cpc	r19, r1
  3c:	04 f4       	brge	.+0      	; 0x3e <DIO_SetPortVal+0x3e>
  3e:	8c 81       	ldd	r24, Y+4	; 0x04
  40:	9d 81       	ldd	r25, Y+5	; 0x05
  42:	00 97       	sbiw	r24, 0x00	; 0
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_SetPortVal+0x46>
  46:	00 c0       	rjmp	.+0      	; 0x48 <DIO_SetPortVal+0x48>
  48:	2c 81       	ldd	r18, Y+4	; 0x04
  4a:	3d 81       	ldd	r19, Y+5	; 0x05
  4c:	22 30       	cpi	r18, 0x02	; 2
  4e:	31 05       	cpc	r19, r1
  50:	01 f0       	breq	.+0      	; 0x52 <DIO_SetPortVal+0x52>
  52:	8c 81       	ldd	r24, Y+4	; 0x04
  54:	9d 81       	ldd	r25, Y+5	; 0x05
  56:	83 30       	cpi	r24, 0x03	; 3
  58:	91 05       	cpc	r25, r1
  5a:	01 f0       	breq	.+0      	; 0x5c <DIO_SetPortVal+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <DIO_SetPortVal+0x5e>
		case DIO_PORTA:
			PORTA = Copy_u8Value;
  5e:	eb e3       	ldi	r30, 0x3B	; 59
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	8b 81       	ldd	r24, Y+3	; 0x03
  64:	80 83       	st	Z, r24
  66:	00 c0       	rjmp	.+0      	; 0x68 <DIO_SetPortVal+0x68>
			break;
		case DIO_PORTB:
			PORTB = Copy_u8Value;
  68:	e8 e3       	ldi	r30, 0x38	; 56
  6a:	f0 e0       	ldi	r31, 0x00	; 0
  6c:	8b 81       	ldd	r24, Y+3	; 0x03
  6e:	80 83       	st	Z, r24
  70:	00 c0       	rjmp	.+0      	; 0x72 <DIO_SetPortVal+0x72>
			break;
		case DIO_PORTC:
			PORTC = Copy_u8Value;
  72:	e5 e3       	ldi	r30, 0x35	; 53
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	8b 81       	ldd	r24, Y+3	; 0x03
  78:	80 83       	st	Z, r24
  7a:	00 c0       	rjmp	.+0      	; 0x7c <DIO_SetPortVal+0x7c>
			break;
		case DIO_PORTD:
			PORTD = Copy_u8Value;
  7c:	e2 e3       	ldi	r30, 0x32	; 50
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	8b 81       	ldd	r24, Y+3	; 0x03
  82:	80 83       	st	Z, r24
			break;
		}
	}

	return Local_u8ErrorState;
  84:	89 81       	ldd	r24, Y+1	; 0x01
}
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	0f 90       	pop	r0
  8c:	0f 90       	pop	r0
  8e:	0f 90       	pop	r0
  90:	cf 91       	pop	r28
  92:	df 91       	pop	r29
  94:	08 95       	ret

Disassembly of section .text.DIO_SetPinVal:

00000000 <DIO_SetPinVal>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/DIO_interface.h"
#include  "../inc/DIO_private.h"
#include "../inc/DIO_register.h"

status_t DIO_SetPortVal(Port_t Copy_Port, u8 Copy_u8Value) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
	status_t Local_u8ErrorState = DIO_ok;
  12:	cd bf       	out	0x3d, r28	; 61
	if ((Copy_Port > DIO_PORTD) || (Copy_Port < DIO_PORTA)) {
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	4c 83       	std	Y+4, r20	; 0x04
		Local_u8ErrorState = DIO_SetErr;
  1a:	19 82       	std	Y+1, r1	; 0x01
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	84 30       	cpi	r24, 0x04	; 4
	} else {
		switch (Copy_Port) {
  20:	00 f0       	brcs	.+0      	; 0x22 <DIO_SetPinVal+0x22>
  22:	81 e0       	ldi	r24, 0x01	; 1
  24:	89 83       	std	Y+1, r24	; 0x01
  26:	00 c0       	rjmp	.+0      	; 0x28 <DIO_SetPinVal+0x28>
  28:	8b 81       	ldd	r24, Y+3	; 0x03
  2a:	88 30       	cpi	r24, 0x08	; 8
  2c:	00 f0       	brcs	.+0      	; 0x2e <DIO_SetPinVal+0x2e>
  2e:	81 e0       	ldi	r24, 0x01	; 1
  30:	89 83       	std	Y+1, r24	; 0x01
  32:	00 c0       	rjmp	.+0      	; 0x34 <DIO_SetPinVal+0x34>
  34:	8c 81       	ldd	r24, Y+4	; 0x04
  36:	81 30       	cpi	r24, 0x01	; 1
  38:	01 f0       	breq	.+0      	; 0x3a <DIO_SetPinVal+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <DIO_SetPinVal+0x3c>
  3c:	8a 81       	ldd	r24, Y+2	; 0x02
  3e:	28 2f       	mov	r18, r24
  40:	30 e0       	ldi	r19, 0x00	; 0
  42:	38 87       	std	Y+8, r19	; 0x08
  44:	2f 83       	std	Y+7, r18	; 0x07
  46:	8f 81       	ldd	r24, Y+7	; 0x07
  48:	98 85       	ldd	r25, Y+8	; 0x08
  4a:	81 30       	cpi	r24, 0x01	; 1
  4c:	91 05       	cpc	r25, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_SetPinVal+0x50>
  50:	2f 81       	ldd	r18, Y+7	; 0x07
  52:	38 85       	ldd	r19, Y+8	; 0x08
  54:	22 30       	cpi	r18, 0x02	; 2
  56:	31 05       	cpc	r19, r1
  58:	04 f4       	brge	.+0      	; 0x5a <DIO_SetPinVal+0x5a>
  5a:	8f 81       	ldd	r24, Y+7	; 0x07
  5c:	98 85       	ldd	r25, Y+8	; 0x08
		case DIO_PORTA:
			PORTA = Copy_u8Value;
  5e:	00 97       	sbiw	r24, 0x00	; 0
  60:	01 f0       	breq	.+0      	; 0x62 <DIO_SetPinVal+0x62>
  62:	00 c0       	rjmp	.+0      	; 0x64 <DIO_SetPinVal+0x64>
  64:	2f 81       	ldd	r18, Y+7	; 0x07
  66:	38 85       	ldd	r19, Y+8	; 0x08
			break;
		case DIO_PORTB:
			PORTB = Copy_u8Value;
  68:	22 30       	cpi	r18, 0x02	; 2
  6a:	31 05       	cpc	r19, r1
  6c:	01 f0       	breq	.+0      	; 0x6e <DIO_SetPinVal+0x6e>
  6e:	8f 81       	ldd	r24, Y+7	; 0x07
  70:	98 85       	ldd	r25, Y+8	; 0x08
			break;
		case DIO_PORTC:
			PORTC = Copy_u8Value;
  72:	83 30       	cpi	r24, 0x03	; 3
  74:	91 05       	cpc	r25, r1
  76:	01 f0       	breq	.+0      	; 0x78 <DIO_SetPinVal+0x78>
  78:	00 c0       	rjmp	.+0      	; 0x7a <DIO_SetPinVal+0x7a>
  7a:	ab e3       	ldi	r26, 0x3B	; 59
			break;
		case DIO_PORTD:
			PORTD = Copy_u8Value;
  7c:	b0 e0       	ldi	r27, 0x00	; 0
  7e:	eb e3       	ldi	r30, 0x3B	; 59
  80:	f0 e0       	ldi	r31, 0x00	; 0
  82:	80 81       	ld	r24, Z
			break;
		}
	}

	return Local_u8ErrorState;
  84:	48 2f       	mov	r20, r24
}
  86:	8b 81       	ldd	r24, Y+3	; 0x03
  88:	28 2f       	mov	r18, r24
  8a:	30 e0       	ldi	r19, 0x00	; 0
  8c:	81 e0       	ldi	r24, 0x01	; 1
  8e:	90 e0       	ldi	r25, 0x00	; 0
  90:	02 2e       	mov	r0, r18
  92:	00 c0       	rjmp	.+0      	; 0x94 <DIO_SetPinVal+0x94>
  94:	88 0f       	add	r24, r24
  96:	99 1f       	adc	r25, r25
  98:	0a 94       	dec	r0
  9a:	02 f4       	brpl	.+0      	; 0x9c <DIO_SetPinVal+0x9c>
  9c:	84 2b       	or	r24, r20
  9e:	8c 93       	st	X, r24
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <DIO_SetPinVal+0xa2>
  a2:	a8 e3       	ldi	r26, 0x38	; 56
  a4:	b0 e0       	ldi	r27, 0x00	; 0
  a6:	e8 e3       	ldi	r30, 0x38	; 56
  a8:	f0 e0       	ldi	r31, 0x00	; 0
  aa:	80 81       	ld	r24, Z
  ac:	48 2f       	mov	r20, r24
  ae:	8b 81       	ldd	r24, Y+3	; 0x03
  b0:	28 2f       	mov	r18, r24
  b2:	30 e0       	ldi	r19, 0x00	; 0
  b4:	81 e0       	ldi	r24, 0x01	; 1
  b6:	90 e0       	ldi	r25, 0x00	; 0
  b8:	02 2e       	mov	r0, r18
  ba:	00 c0       	rjmp	.+0      	; 0xbc <DIO_SetPinVal+0xbc>
  bc:	88 0f       	add	r24, r24
  be:	99 1f       	adc	r25, r25
  c0:	0a 94       	dec	r0
  c2:	02 f4       	brpl	.+0      	; 0xc4 <DIO_SetPinVal+0xc4>
  c4:	84 2b       	or	r24, r20
  c6:	8c 93       	st	X, r24
  c8:	00 c0       	rjmp	.+0      	; 0xca <DIO_SetPinVal+0xca>
  ca:	a5 e3       	ldi	r26, 0x35	; 53
  cc:	b0 e0       	ldi	r27, 0x00	; 0
  ce:	e5 e3       	ldi	r30, 0x35	; 53
  d0:	f0 e0       	ldi	r31, 0x00	; 0
  d2:	80 81       	ld	r24, Z
  d4:	48 2f       	mov	r20, r24
  d6:	8b 81       	ldd	r24, Y+3	; 0x03
  d8:	28 2f       	mov	r18, r24
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	90 e0       	ldi	r25, 0x00	; 0
  e0:	02 2e       	mov	r0, r18
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <DIO_SetPinVal+0xe4>
  e4:	88 0f       	add	r24, r24
  e6:	99 1f       	adc	r25, r25
  e8:	0a 94       	dec	r0
  ea:	02 f4       	brpl	.+0      	; 0xec <DIO_SetPinVal+0xec>
  ec:	84 2b       	or	r24, r20
  ee:	8c 93       	st	X, r24
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <DIO_SetPinVal+0xf2>
  f2:	a2 e3       	ldi	r26, 0x32	; 50
  f4:	b0 e0       	ldi	r27, 0x00	; 0
  f6:	e2 e3       	ldi	r30, 0x32	; 50
  f8:	f0 e0       	ldi	r31, 0x00	; 0
  fa:	80 81       	ld	r24, Z
  fc:	48 2f       	mov	r20, r24
  fe:	8b 81       	ldd	r24, Y+3	; 0x03
 100:	28 2f       	mov	r18, r24
 102:	30 e0       	ldi	r19, 0x00	; 0
 104:	81 e0       	ldi	r24, 0x01	; 1
 106:	90 e0       	ldi	r25, 0x00	; 0
 108:	02 2e       	mov	r0, r18
 10a:	00 c0       	rjmp	.+0      	; 0x10c <DIO_SetPinVal+0x10c>
 10c:	88 0f       	add	r24, r24
 10e:	99 1f       	adc	r25, r25
 110:	0a 94       	dec	r0
 112:	02 f4       	brpl	.+0      	; 0x114 <DIO_SetPinVal+0x114>
 114:	84 2b       	or	r24, r20
 116:	8c 93       	st	X, r24
 118:	00 c0       	rjmp	.+0      	; 0x11a <DIO_SetPinVal+0x11a>
 11a:	8c 81       	ldd	r24, Y+4	; 0x04
 11c:	88 23       	and	r24, r24
 11e:	01 f0       	breq	.+0      	; 0x120 <DIO_SetPinVal+0x120>
 120:	00 c0       	rjmp	.+0      	; 0x122 <DIO_SetPinVal+0x122>
 122:	8a 81       	ldd	r24, Y+2	; 0x02
 124:	28 2f       	mov	r18, r24
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	3e 83       	std	Y+6, r19	; 0x06
 12a:	2d 83       	std	Y+5, r18	; 0x05
 12c:	8d 81       	ldd	r24, Y+5	; 0x05
 12e:	9e 81       	ldd	r25, Y+6	; 0x06
 130:	81 30       	cpi	r24, 0x01	; 1
 132:	91 05       	cpc	r25, r1
 134:	01 f0       	breq	.+0      	; 0x136 <DIO_SetPinVal+0x136>
 136:	2d 81       	ldd	r18, Y+5	; 0x05
 138:	3e 81       	ldd	r19, Y+6	; 0x06
 13a:	22 30       	cpi	r18, 0x02	; 2
 13c:	31 05       	cpc	r19, r1
 13e:	04 f4       	brge	.+0      	; 0x140 <DIO_SetPinVal+0x140>
 140:	8d 81       	ldd	r24, Y+5	; 0x05
 142:	9e 81       	ldd	r25, Y+6	; 0x06
 144:	00 97       	sbiw	r24, 0x00	; 0
 146:	01 f0       	breq	.+0      	; 0x148 <DIO_SetPinVal+0x148>
 148:	00 c0       	rjmp	.+0      	; 0x14a <DIO_SetPinVal+0x14a>
 14a:	2d 81       	ldd	r18, Y+5	; 0x05
 14c:	3e 81       	ldd	r19, Y+6	; 0x06
 14e:	22 30       	cpi	r18, 0x02	; 2
 150:	31 05       	cpc	r19, r1
 152:	01 f0       	breq	.+0      	; 0x154 <DIO_SetPinVal+0x154>
 154:	8d 81       	ldd	r24, Y+5	; 0x05
 156:	9e 81       	ldd	r25, Y+6	; 0x06
 158:	83 30       	cpi	r24, 0x03	; 3
 15a:	91 05       	cpc	r25, r1
 15c:	01 f4       	brne	.+0      	; 0x15e <DIO_SetPinVal+0x15e>
 15e:	00 c0       	rjmp	.+0      	; 0x160 <DIO_SetPinVal+0x160>
 160:	00 c0       	rjmp	.+0      	; 0x162 <DIO_SetPinVal+0x162>
 162:	ab e3       	ldi	r26, 0x3B	; 59
 164:	b0 e0       	ldi	r27, 0x00	; 0
 166:	eb e3       	ldi	r30, 0x3B	; 59
 168:	f0 e0       	ldi	r31, 0x00	; 0
 16a:	80 81       	ld	r24, Z
 16c:	48 2f       	mov	r20, r24
 16e:	8b 81       	ldd	r24, Y+3	; 0x03
 170:	28 2f       	mov	r18, r24
 172:	30 e0       	ldi	r19, 0x00	; 0
 174:	81 e0       	ldi	r24, 0x01	; 1
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	02 2e       	mov	r0, r18
 17a:	00 c0       	rjmp	.+0      	; 0x17c <DIO_SetPinVal+0x17c>
 17c:	88 0f       	add	r24, r24
 17e:	99 1f       	adc	r25, r25
 180:	0a 94       	dec	r0
 182:	02 f4       	brpl	.+0      	; 0x184 <DIO_SetPinVal+0x184>
 184:	80 95       	com	r24
 186:	84 23       	and	r24, r20
 188:	8c 93       	st	X, r24
 18a:	00 c0       	rjmp	.+0      	; 0x18c <DIO_SetPinVal+0x18c>
 18c:	a8 e3       	ldi	r26, 0x38	; 56
 18e:	b0 e0       	ldi	r27, 0x00	; 0
 190:	e8 e3       	ldi	r30, 0x38	; 56
 192:	f0 e0       	ldi	r31, 0x00	; 0
 194:	80 81       	ld	r24, Z
 196:	48 2f       	mov	r20, r24
 198:	8b 81       	ldd	r24, Y+3	; 0x03
 19a:	28 2f       	mov	r18, r24
 19c:	30 e0       	ldi	r19, 0x00	; 0
 19e:	81 e0       	ldi	r24, 0x01	; 1
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	02 2e       	mov	r0, r18
 1a4:	00 c0       	rjmp	.+0      	; 0x1a6 <DIO_SetPinVal+0x1a6>
 1a6:	88 0f       	add	r24, r24
 1a8:	99 1f       	adc	r25, r25
 1aa:	0a 94       	dec	r0
 1ac:	02 f4       	brpl	.+0      	; 0x1ae <DIO_SetPinVal+0x1ae>
 1ae:	80 95       	com	r24
 1b0:	84 23       	and	r24, r20
 1b2:	8c 93       	st	X, r24
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <DIO_SetPinVal+0x1b6>
 1b6:	a5 e3       	ldi	r26, 0x35	; 53
 1b8:	b0 e0       	ldi	r27, 0x00	; 0
 1ba:	e5 e3       	ldi	r30, 0x35	; 53
 1bc:	f0 e0       	ldi	r31, 0x00	; 0
 1be:	80 81       	ld	r24, Z
 1c0:	48 2f       	mov	r20, r24
 1c2:	8b 81       	ldd	r24, Y+3	; 0x03
 1c4:	28 2f       	mov	r18, r24
 1c6:	30 e0       	ldi	r19, 0x00	; 0
 1c8:	81 e0       	ldi	r24, 0x01	; 1
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	02 2e       	mov	r0, r18
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <DIO_SetPinVal+0x1d0>
 1d0:	88 0f       	add	r24, r24
 1d2:	99 1f       	adc	r25, r25
 1d4:	0a 94       	dec	r0
 1d6:	02 f4       	brpl	.+0      	; 0x1d8 <DIO_SetPinVal+0x1d8>
 1d8:	80 95       	com	r24
 1da:	84 23       	and	r24, r20
 1dc:	8c 93       	st	X, r24
 1de:	00 c0       	rjmp	.+0      	; 0x1e0 <DIO_SetPinVal+0x1e0>
 1e0:	a2 e3       	ldi	r26, 0x32	; 50
 1e2:	b0 e0       	ldi	r27, 0x00	; 0
 1e4:	e2 e3       	ldi	r30, 0x32	; 50
 1e6:	f0 e0       	ldi	r31, 0x00	; 0
 1e8:	80 81       	ld	r24, Z
 1ea:	48 2f       	mov	r20, r24
 1ec:	8b 81       	ldd	r24, Y+3	; 0x03
 1ee:	28 2f       	mov	r18, r24
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	81 e0       	ldi	r24, 0x01	; 1
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	02 2e       	mov	r0, r18
 1f8:	00 c0       	rjmp	.+0      	; 0x1fa <DIO_SetPinVal+0x1fa>
 1fa:	88 0f       	add	r24, r24
 1fc:	99 1f       	adc	r25, r25
 1fe:	0a 94       	dec	r0
 200:	02 f4       	brpl	.+0      	; 0x202 <DIO_SetPinVal+0x202>
 202:	80 95       	com	r24
 204:	84 23       	and	r24, r20
 206:	8c 93       	st	X, r24
 208:	89 81       	ldd	r24, Y+1	; 0x01
 20a:	28 96       	adiw	r28, 0x08	; 8
 20c:	0f b6       	in	r0, 0x3f	; 63
 20e:	f8 94       	cli
 210:	de bf       	out	0x3e, r29	; 62
 212:	0f be       	out	0x3f, r0	; 63
 214:	cd bf       	out	0x3d, r28	; 61
 216:	cf 91       	pop	r28
 218:	df 91       	pop	r29
 21a:	08 95       	ret

Disassembly of section .text.DIO_SetPortDir:

00000000 <DIO_SetPortDir>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/DIO_interface.h"
#include  "../inc/DIO_private.h"
#include "../inc/DIO_register.h"

status_t DIO_SetPortVal(Port_t Copy_Port, u8 Copy_u8Value) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_SetPortDir+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_SetPortDir+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
	status_t Local_u8ErrorState = DIO_ok;
  12:	19 82       	std	Y+1, r1	; 0x01
	if ((Copy_Port > DIO_PORTD) || (Copy_Port < DIO_PORTA)) {
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	84 30       	cpi	r24, 0x04	; 4
  18:	00 f0       	brcs	.+0      	; 0x1a <DIO_SetPortDir+0x1a>
		Local_u8ErrorState = DIO_SetErr;
  1a:	83 e0       	ldi	r24, 0x03	; 3
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	00 c0       	rjmp	.+0      	; 0x20 <DIO_SetPortDir+0x20>
	} else {
		switch (Copy_Port) {
  20:	8a 81       	ldd	r24, Y+2	; 0x02
  22:	28 2f       	mov	r18, r24
  24:	30 e0       	ldi	r19, 0x00	; 0
  26:	3d 83       	std	Y+5, r19	; 0x05
  28:	2c 83       	std	Y+4, r18	; 0x04
  2a:	8c 81       	ldd	r24, Y+4	; 0x04
  2c:	9d 81       	ldd	r25, Y+5	; 0x05
  2e:	81 30       	cpi	r24, 0x01	; 1
  30:	91 05       	cpc	r25, r1
  32:	01 f0       	breq	.+0      	; 0x34 <DIO_SetPortDir+0x34>
  34:	2c 81       	ldd	r18, Y+4	; 0x04
  36:	3d 81       	ldd	r19, Y+5	; 0x05
  38:	22 30       	cpi	r18, 0x02	; 2
  3a:	31 05       	cpc	r19, r1
  3c:	04 f4       	brge	.+0      	; 0x3e <DIO_SetPortDir+0x3e>
  3e:	8c 81       	ldd	r24, Y+4	; 0x04
  40:	9d 81       	ldd	r25, Y+5	; 0x05
  42:	00 97       	sbiw	r24, 0x00	; 0
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_SetPortDir+0x46>
  46:	00 c0       	rjmp	.+0      	; 0x48 <DIO_SetPortDir+0x48>
  48:	2c 81       	ldd	r18, Y+4	; 0x04
  4a:	3d 81       	ldd	r19, Y+5	; 0x05
  4c:	22 30       	cpi	r18, 0x02	; 2
  4e:	31 05       	cpc	r19, r1
  50:	01 f0       	breq	.+0      	; 0x52 <DIO_SetPortDir+0x52>
  52:	8c 81       	ldd	r24, Y+4	; 0x04
  54:	9d 81       	ldd	r25, Y+5	; 0x05
  56:	83 30       	cpi	r24, 0x03	; 3
  58:	91 05       	cpc	r25, r1
  5a:	01 f0       	breq	.+0      	; 0x5c <DIO_SetPortDir+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <DIO_SetPortDir+0x5e>
		case DIO_PORTA:
			PORTA = Copy_u8Value;
  5e:	ea e3       	ldi	r30, 0x3A	; 58
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	8b 81       	ldd	r24, Y+3	; 0x03
  64:	80 83       	st	Z, r24
  66:	00 c0       	rjmp	.+0      	; 0x68 <DIO_SetPortDir+0x68>
			break;
		case DIO_PORTB:
			PORTB = Copy_u8Value;
  68:	e7 e3       	ldi	r30, 0x37	; 55
  6a:	f0 e0       	ldi	r31, 0x00	; 0
  6c:	8b 81       	ldd	r24, Y+3	; 0x03
  6e:	80 83       	st	Z, r24
  70:	00 c0       	rjmp	.+0      	; 0x72 <DIO_SetPortDir+0x72>
			break;
		case DIO_PORTC:
			PORTC = Copy_u8Value;
  72:	e4 e3       	ldi	r30, 0x34	; 52
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	8b 81       	ldd	r24, Y+3	; 0x03
  78:	80 83       	st	Z, r24
  7a:	00 c0       	rjmp	.+0      	; 0x7c <DIO_SetPortDir+0x7c>
			break;
		case DIO_PORTD:
			PORTD = Copy_u8Value;
  7c:	e1 e3       	ldi	r30, 0x31	; 49
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	8b 81       	ldd	r24, Y+3	; 0x03
  82:	80 83       	st	Z, r24
			break;
		}
	}

	return Local_u8ErrorState;
  84:	89 81       	ldd	r24, Y+1	; 0x01
}
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	0f 90       	pop	r0
  8c:	0f 90       	pop	r0
  8e:	0f 90       	pop	r0
  90:	cf 91       	pop	r28
  92:	df 91       	pop	r29
  94:	08 95       	ret

Disassembly of section .text.DIO_SetPinDir:

00000000 <DIO_SetPinDir>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/DIO_interface.h"
#include  "../inc/DIO_private.h"
#include "../inc/DIO_register.h"

status_t DIO_SetPortVal(Port_t Copy_Port, u8 Copy_u8Value) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
	status_t Local_u8ErrorState = DIO_ok;
  12:	cd bf       	out	0x3d, r28	; 61
	if ((Copy_Port > DIO_PORTD) || (Copy_Port < DIO_PORTA)) {
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	4c 83       	std	Y+4, r20	; 0x04
		Local_u8ErrorState = DIO_SetErr;
  1a:	19 82       	std	Y+1, r1	; 0x01
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	84 30       	cpi	r24, 0x04	; 4
	} else {
		switch (Copy_Port) {
  20:	00 f0       	brcs	.+0      	; 0x22 <DIO_SetPinDir+0x22>
  22:	83 e0       	ldi	r24, 0x03	; 3
  24:	89 83       	std	Y+1, r24	; 0x01
  26:	00 c0       	rjmp	.+0      	; 0x28 <DIO_SetPinDir+0x28>
  28:	8b 81       	ldd	r24, Y+3	; 0x03
  2a:	88 30       	cpi	r24, 0x08	; 8
  2c:	00 f0       	brcs	.+0      	; 0x2e <DIO_SetPinDir+0x2e>
  2e:	83 e0       	ldi	r24, 0x03	; 3
  30:	89 83       	std	Y+1, r24	; 0x01
  32:	00 c0       	rjmp	.+0      	; 0x34 <DIO_SetPinDir+0x34>
  34:	8c 81       	ldd	r24, Y+4	; 0x04
  36:	88 23       	and	r24, r24
  38:	01 f0       	breq	.+0      	; 0x3a <DIO_SetPinDir+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <DIO_SetPinDir+0x3c>
  3c:	8a 81       	ldd	r24, Y+2	; 0x02
  3e:	28 2f       	mov	r18, r24
  40:	30 e0       	ldi	r19, 0x00	; 0
  42:	38 87       	std	Y+8, r19	; 0x08
  44:	2f 83       	std	Y+7, r18	; 0x07
  46:	8f 81       	ldd	r24, Y+7	; 0x07
  48:	98 85       	ldd	r25, Y+8	; 0x08
  4a:	81 30       	cpi	r24, 0x01	; 1
  4c:	91 05       	cpc	r25, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_SetPinDir+0x50>
  50:	2f 81       	ldd	r18, Y+7	; 0x07
  52:	38 85       	ldd	r19, Y+8	; 0x08
  54:	22 30       	cpi	r18, 0x02	; 2
  56:	31 05       	cpc	r19, r1
  58:	04 f4       	brge	.+0      	; 0x5a <DIO_SetPinDir+0x5a>
  5a:	8f 81       	ldd	r24, Y+7	; 0x07
  5c:	98 85       	ldd	r25, Y+8	; 0x08
		case DIO_PORTA:
			PORTA = Copy_u8Value;
  5e:	00 97       	sbiw	r24, 0x00	; 0
  60:	01 f0       	breq	.+0      	; 0x62 <DIO_SetPinDir+0x62>
  62:	00 c0       	rjmp	.+0      	; 0x64 <DIO_SetPinDir+0x64>
  64:	2f 81       	ldd	r18, Y+7	; 0x07
  66:	38 85       	ldd	r19, Y+8	; 0x08
			break;
		case DIO_PORTB:
			PORTB = Copy_u8Value;
  68:	22 30       	cpi	r18, 0x02	; 2
  6a:	31 05       	cpc	r19, r1
  6c:	01 f0       	breq	.+0      	; 0x6e <DIO_SetPinDir+0x6e>
  6e:	8f 81       	ldd	r24, Y+7	; 0x07
  70:	98 85       	ldd	r25, Y+8	; 0x08
			break;
		case DIO_PORTC:
			PORTC = Copy_u8Value;
  72:	83 30       	cpi	r24, 0x03	; 3
  74:	91 05       	cpc	r25, r1
  76:	01 f4       	brne	.+0      	; 0x78 <DIO_SetPinDir+0x78>
  78:	00 c0       	rjmp	.+0      	; 0x7a <DIO_SetPinDir+0x7a>
  7a:	00 c0       	rjmp	.+0      	; 0x7c <DIO_SetPinDir+0x7c>
			break;
		case DIO_PORTD:
			PORTD = Copy_u8Value;
  7c:	aa e3       	ldi	r26, 0x3A	; 58
  7e:	b0 e0       	ldi	r27, 0x00	; 0
  80:	ea e3       	ldi	r30, 0x3A	; 58
  82:	f0 e0       	ldi	r31, 0x00	; 0
			break;
		}
	}

	return Local_u8ErrorState;
  84:	80 81       	ld	r24, Z
}
  86:	48 2f       	mov	r20, r24
  88:	8b 81       	ldd	r24, Y+3	; 0x03
  8a:	28 2f       	mov	r18, r24
  8c:	30 e0       	ldi	r19, 0x00	; 0
  8e:	81 e0       	ldi	r24, 0x01	; 1
  90:	90 e0       	ldi	r25, 0x00	; 0
  92:	02 2e       	mov	r0, r18
  94:	00 c0       	rjmp	.+0      	; 0x96 <DIO_SetPinDir+0x96>
  96:	88 0f       	add	r24, r24
  98:	99 1f       	adc	r25, r25
  9a:	0a 94       	dec	r0
  9c:	02 f4       	brpl	.+0      	; 0x9e <DIO_SetPinDir+0x9e>
  9e:	80 95       	com	r24
  a0:	84 23       	and	r24, r20
  a2:	8c 93       	st	X, r24
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <DIO_SetPinDir+0xa6>
  a6:	a7 e3       	ldi	r26, 0x37	; 55
  a8:	b0 e0       	ldi	r27, 0x00	; 0
  aa:	e7 e3       	ldi	r30, 0x37	; 55
  ac:	f0 e0       	ldi	r31, 0x00	; 0
  ae:	80 81       	ld	r24, Z
  b0:	48 2f       	mov	r20, r24
  b2:	8b 81       	ldd	r24, Y+3	; 0x03
  b4:	28 2f       	mov	r18, r24
  b6:	30 e0       	ldi	r19, 0x00	; 0
  b8:	81 e0       	ldi	r24, 0x01	; 1
  ba:	90 e0       	ldi	r25, 0x00	; 0
  bc:	02 2e       	mov	r0, r18
  be:	00 c0       	rjmp	.+0      	; 0xc0 <DIO_SetPinDir+0xc0>
  c0:	88 0f       	add	r24, r24
  c2:	99 1f       	adc	r25, r25
  c4:	0a 94       	dec	r0
  c6:	02 f4       	brpl	.+0      	; 0xc8 <DIO_SetPinDir+0xc8>
  c8:	80 95       	com	r24
  ca:	84 23       	and	r24, r20
  cc:	8c 93       	st	X, r24
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <DIO_SetPinDir+0xd0>
  d0:	a4 e3       	ldi	r26, 0x34	; 52
  d2:	b0 e0       	ldi	r27, 0x00	; 0
  d4:	e4 e3       	ldi	r30, 0x34	; 52
  d6:	f0 e0       	ldi	r31, 0x00	; 0
  d8:	80 81       	ld	r24, Z
  da:	48 2f       	mov	r20, r24
  dc:	8b 81       	ldd	r24, Y+3	; 0x03
  de:	28 2f       	mov	r18, r24
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	02 2e       	mov	r0, r18
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_SetPinDir+0xea>
  ea:	88 0f       	add	r24, r24
  ec:	99 1f       	adc	r25, r25
  ee:	0a 94       	dec	r0
  f0:	02 f4       	brpl	.+0      	; 0xf2 <DIO_SetPinDir+0xf2>
  f2:	80 95       	com	r24
  f4:	84 23       	and	r24, r20
  f6:	8c 93       	st	X, r24
  f8:	00 c0       	rjmp	.+0      	; 0xfa <DIO_SetPinDir+0xfa>
  fa:	a1 e3       	ldi	r26, 0x31	; 49
  fc:	b0 e0       	ldi	r27, 0x00	; 0
  fe:	e1 e3       	ldi	r30, 0x31	; 49
 100:	f0 e0       	ldi	r31, 0x00	; 0
 102:	80 81       	ld	r24, Z
 104:	48 2f       	mov	r20, r24
 106:	8b 81       	ldd	r24, Y+3	; 0x03
 108:	28 2f       	mov	r18, r24
 10a:	30 e0       	ldi	r19, 0x00	; 0
 10c:	81 e0       	ldi	r24, 0x01	; 1
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	02 2e       	mov	r0, r18
 112:	00 c0       	rjmp	.+0      	; 0x114 <DIO_SetPinDir+0x114>
 114:	88 0f       	add	r24, r24
 116:	99 1f       	adc	r25, r25
 118:	0a 94       	dec	r0
 11a:	02 f4       	brpl	.+0      	; 0x11c <DIO_SetPinDir+0x11c>
 11c:	80 95       	com	r24
 11e:	84 23       	and	r24, r20
 120:	8c 93       	st	X, r24
 122:	00 c0       	rjmp	.+0      	; 0x124 <DIO_SetPinDir+0x124>
 124:	8c 81       	ldd	r24, Y+4	; 0x04
 126:	81 30       	cpi	r24, 0x01	; 1
 128:	01 f0       	breq	.+0      	; 0x12a <DIO_SetPinDir+0x12a>
 12a:	00 c0       	rjmp	.+0      	; 0x12c <DIO_SetPinDir+0x12c>
 12c:	8a 81       	ldd	r24, Y+2	; 0x02
 12e:	28 2f       	mov	r18, r24
 130:	30 e0       	ldi	r19, 0x00	; 0
 132:	3e 83       	std	Y+6, r19	; 0x06
 134:	2d 83       	std	Y+5, r18	; 0x05
 136:	8d 81       	ldd	r24, Y+5	; 0x05
 138:	9e 81       	ldd	r25, Y+6	; 0x06
 13a:	81 30       	cpi	r24, 0x01	; 1
 13c:	91 05       	cpc	r25, r1
 13e:	01 f0       	breq	.+0      	; 0x140 <DIO_SetPinDir+0x140>
 140:	2d 81       	ldd	r18, Y+5	; 0x05
 142:	3e 81       	ldd	r19, Y+6	; 0x06
 144:	22 30       	cpi	r18, 0x02	; 2
 146:	31 05       	cpc	r19, r1
 148:	04 f4       	brge	.+0      	; 0x14a <DIO_SetPinDir+0x14a>
 14a:	8d 81       	ldd	r24, Y+5	; 0x05
 14c:	9e 81       	ldd	r25, Y+6	; 0x06
 14e:	00 97       	sbiw	r24, 0x00	; 0
 150:	01 f0       	breq	.+0      	; 0x152 <DIO_SetPinDir+0x152>
 152:	00 c0       	rjmp	.+0      	; 0x154 <DIO_SetPinDir+0x154>
 154:	2d 81       	ldd	r18, Y+5	; 0x05
 156:	3e 81       	ldd	r19, Y+6	; 0x06
 158:	22 30       	cpi	r18, 0x02	; 2
 15a:	31 05       	cpc	r19, r1
 15c:	01 f0       	breq	.+0      	; 0x15e <DIO_SetPinDir+0x15e>
 15e:	8d 81       	ldd	r24, Y+5	; 0x05
 160:	9e 81       	ldd	r25, Y+6	; 0x06
 162:	83 30       	cpi	r24, 0x03	; 3
 164:	91 05       	cpc	r25, r1
 166:	01 f0       	breq	.+0      	; 0x168 <DIO_SetPinDir+0x168>
 168:	00 c0       	rjmp	.+0      	; 0x16a <DIO_SetPinDir+0x16a>
 16a:	aa e3       	ldi	r26, 0x3A	; 58
 16c:	b0 e0       	ldi	r27, 0x00	; 0
 16e:	ea e3       	ldi	r30, 0x3A	; 58
 170:	f0 e0       	ldi	r31, 0x00	; 0
 172:	80 81       	ld	r24, Z
 174:	48 2f       	mov	r20, r24
 176:	8b 81       	ldd	r24, Y+3	; 0x03
 178:	28 2f       	mov	r18, r24
 17a:	30 e0       	ldi	r19, 0x00	; 0
 17c:	81 e0       	ldi	r24, 0x01	; 1
 17e:	90 e0       	ldi	r25, 0x00	; 0
 180:	02 2e       	mov	r0, r18
 182:	00 c0       	rjmp	.+0      	; 0x184 <DIO_SetPinDir+0x184>
 184:	88 0f       	add	r24, r24
 186:	99 1f       	adc	r25, r25
 188:	0a 94       	dec	r0
 18a:	02 f4       	brpl	.+0      	; 0x18c <DIO_SetPinDir+0x18c>
 18c:	84 2b       	or	r24, r20
 18e:	8c 93       	st	X, r24
 190:	00 c0       	rjmp	.+0      	; 0x192 <DIO_SetPinDir+0x192>
 192:	a7 e3       	ldi	r26, 0x37	; 55
 194:	b0 e0       	ldi	r27, 0x00	; 0
 196:	e7 e3       	ldi	r30, 0x37	; 55
 198:	f0 e0       	ldi	r31, 0x00	; 0
 19a:	80 81       	ld	r24, Z
 19c:	48 2f       	mov	r20, r24
 19e:	8b 81       	ldd	r24, Y+3	; 0x03
 1a0:	28 2f       	mov	r18, r24
 1a2:	30 e0       	ldi	r19, 0x00	; 0
 1a4:	81 e0       	ldi	r24, 0x01	; 1
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	02 2e       	mov	r0, r18
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <DIO_SetPinDir+0x1ac>
 1ac:	88 0f       	add	r24, r24
 1ae:	99 1f       	adc	r25, r25
 1b0:	0a 94       	dec	r0
 1b2:	02 f4       	brpl	.+0      	; 0x1b4 <DIO_SetPinDir+0x1b4>
 1b4:	84 2b       	or	r24, r20
 1b6:	8c 93       	st	X, r24
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <DIO_SetPinDir+0x1ba>
 1ba:	a4 e3       	ldi	r26, 0x34	; 52
 1bc:	b0 e0       	ldi	r27, 0x00	; 0
 1be:	e4 e3       	ldi	r30, 0x34	; 52
 1c0:	f0 e0       	ldi	r31, 0x00	; 0
 1c2:	80 81       	ld	r24, Z
 1c4:	48 2f       	mov	r20, r24
 1c6:	8b 81       	ldd	r24, Y+3	; 0x03
 1c8:	28 2f       	mov	r18, r24
 1ca:	30 e0       	ldi	r19, 0x00	; 0
 1cc:	81 e0       	ldi	r24, 0x01	; 1
 1ce:	90 e0       	ldi	r25, 0x00	; 0
 1d0:	02 2e       	mov	r0, r18
 1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <DIO_SetPinDir+0x1d4>
 1d4:	88 0f       	add	r24, r24
 1d6:	99 1f       	adc	r25, r25
 1d8:	0a 94       	dec	r0
 1da:	02 f4       	brpl	.+0      	; 0x1dc <DIO_SetPinDir+0x1dc>
 1dc:	84 2b       	or	r24, r20
 1de:	8c 93       	st	X, r24
 1e0:	00 c0       	rjmp	.+0      	; 0x1e2 <DIO_SetPinDir+0x1e2>
 1e2:	a1 e3       	ldi	r26, 0x31	; 49
 1e4:	b0 e0       	ldi	r27, 0x00	; 0
 1e6:	e1 e3       	ldi	r30, 0x31	; 49
 1e8:	f0 e0       	ldi	r31, 0x00	; 0
 1ea:	80 81       	ld	r24, Z
 1ec:	48 2f       	mov	r20, r24
 1ee:	8b 81       	ldd	r24, Y+3	; 0x03
 1f0:	28 2f       	mov	r18, r24
 1f2:	30 e0       	ldi	r19, 0x00	; 0
 1f4:	81 e0       	ldi	r24, 0x01	; 1
 1f6:	90 e0       	ldi	r25, 0x00	; 0
 1f8:	02 2e       	mov	r0, r18
 1fa:	00 c0       	rjmp	.+0      	; 0x1fc <DIO_SetPinDir+0x1fc>
 1fc:	88 0f       	add	r24, r24
 1fe:	99 1f       	adc	r25, r25
 200:	0a 94       	dec	r0
 202:	02 f4       	brpl	.+0      	; 0x204 <DIO_SetPinDir+0x204>
 204:	84 2b       	or	r24, r20
 206:	8c 93       	st	X, r24
 208:	89 81       	ldd	r24, Y+1	; 0x01
 20a:	28 96       	adiw	r28, 0x08	; 8
 20c:	0f b6       	in	r0, 0x3f	; 63
 20e:	f8 94       	cli
 210:	de bf       	out	0x3e, r29	; 62
 212:	0f be       	out	0x3f, r0	; 63
 214:	cd bf       	out	0x3d, r28	; 61
 216:	cf 91       	pop	r28
 218:	df 91       	pop	r29
 21a:	08 95       	ret

Disassembly of section .text.DIO_GetPinVal:

00000000 <DIO_GetPinVal>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/DIO_interface.h"
#include  "../inc/DIO_private.h"
#include "../inc/DIO_register.h"

status_t DIO_SetPortVal(Port_t Copy_Port, u8 Copy_u8Value) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	27 97       	sbiw	r28, 0x07	; 7
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
	status_t Local_u8ErrorState = DIO_ok;
  12:	cd bf       	out	0x3d, r28	; 61
	if ((Copy_Port > DIO_PORTD) || (Copy_Port < DIO_PORTA)) {
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	5d 83       	std	Y+5, r21	; 0x05
		Local_u8ErrorState = DIO_SetErr;
  1a:	4c 83       	std	Y+4, r20	; 0x04
  1c:	19 82       	std	Y+1, r1	; 0x01
  1e:	8a 81       	ldd	r24, Y+2	; 0x02
	} else {
		switch (Copy_Port) {
  20:	84 30       	cpi	r24, 0x04	; 4
  22:	00 f0       	brcs	.+0      	; 0x24 <DIO_GetPinVal+0x24>
  24:	82 e0       	ldi	r24, 0x02	; 2
  26:	89 83       	std	Y+1, r24	; 0x01
  28:	00 c0       	rjmp	.+0      	; 0x2a <DIO_GetPinVal+0x2a>
  2a:	8b 81       	ldd	r24, Y+3	; 0x03
  2c:	88 30       	cpi	r24, 0x08	; 8
  2e:	00 f0       	brcs	.+0      	; 0x30 <DIO_GetPinVal+0x30>
  30:	82 e0       	ldi	r24, 0x02	; 2
  32:	89 83       	std	Y+1, r24	; 0x01
  34:	00 c0       	rjmp	.+0      	; 0x36 <DIO_GetPinVal+0x36>
  36:	8a 81       	ldd	r24, Y+2	; 0x02
  38:	28 2f       	mov	r18, r24
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	3f 83       	std	Y+7, r19	; 0x07
  3e:	2e 83       	std	Y+6, r18	; 0x06
  40:	4e 81       	ldd	r20, Y+6	; 0x06
  42:	5f 81       	ldd	r21, Y+7	; 0x07
  44:	41 30       	cpi	r20, 0x01	; 1
  46:	51 05       	cpc	r21, r1
  48:	01 f0       	breq	.+0      	; 0x4a <DIO_GetPinVal+0x4a>
  4a:	8e 81       	ldd	r24, Y+6	; 0x06
  4c:	9f 81       	ldd	r25, Y+7	; 0x07
  4e:	82 30       	cpi	r24, 0x02	; 2
  50:	91 05       	cpc	r25, r1
  52:	04 f4       	brge	.+0      	; 0x54 <DIO_GetPinVal+0x54>
  54:	2e 81       	ldd	r18, Y+6	; 0x06
  56:	3f 81       	ldd	r19, Y+7	; 0x07
  58:	21 15       	cp	r18, r1
  5a:	31 05       	cpc	r19, r1
  5c:	01 f0       	breq	.+0      	; 0x5e <DIO_GetPinVal+0x5e>
		case DIO_PORTA:
			PORTA = Copy_u8Value;
  5e:	00 c0       	rjmp	.+0      	; 0x60 <DIO_GetPinVal+0x60>
  60:	4e 81       	ldd	r20, Y+6	; 0x06
  62:	5f 81       	ldd	r21, Y+7	; 0x07
  64:	42 30       	cpi	r20, 0x02	; 2
  66:	51 05       	cpc	r21, r1
			break;
		case DIO_PORTB:
			PORTB = Copy_u8Value;
  68:	01 f0       	breq	.+0      	; 0x6a <DIO_GetPinVal+0x6a>
  6a:	8e 81       	ldd	r24, Y+6	; 0x06
  6c:	9f 81       	ldd	r25, Y+7	; 0x07
  6e:	83 30       	cpi	r24, 0x03	; 3
  70:	91 05       	cpc	r25, r1
			break;
		case DIO_PORTC:
			PORTC = Copy_u8Value;
  72:	01 f4       	brne	.+0      	; 0x74 <DIO_GetPinVal+0x74>
  74:	00 c0       	rjmp	.+0      	; 0x76 <DIO_GetPinVal+0x76>
  76:	00 c0       	rjmp	.+0      	; 0x78 <DIO_GetPinVal+0x78>
  78:	e9 e3       	ldi	r30, 0x39	; 57
  7a:	f0 e0       	ldi	r31, 0x00	; 0
			break;
		case DIO_PORTD:
			PORTD = Copy_u8Value;
  7c:	80 81       	ld	r24, Z
  7e:	28 2f       	mov	r18, r24
  80:	30 e0       	ldi	r19, 0x00	; 0
  82:	8b 81       	ldd	r24, Y+3	; 0x03
			break;
		}
	}

	return Local_u8ErrorState;
  84:	88 2f       	mov	r24, r24
}
  86:	90 e0       	ldi	r25, 0x00	; 0
  88:	a9 01       	movw	r20, r18
  8a:	00 c0       	rjmp	.+0      	; 0x8c <DIO_GetPinVal+0x8c>
  8c:	55 95       	asr	r21
  8e:	47 95       	ror	r20
  90:	8a 95       	dec	r24
  92:	02 f4       	brpl	.+0      	; 0x94 <DIO_GetPinVal+0x94>
  94:	ca 01       	movw	r24, r20
  96:	81 70       	andi	r24, 0x01	; 1
  98:	ec 81       	ldd	r30, Y+4	; 0x04
  9a:	fd 81       	ldd	r31, Y+5	; 0x05
  9c:	80 83       	st	Z, r24
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <DIO_GetPinVal+0xa0>
  a0:	e6 e3       	ldi	r30, 0x36	; 54
  a2:	f0 e0       	ldi	r31, 0x00	; 0
  a4:	80 81       	ld	r24, Z
  a6:	28 2f       	mov	r18, r24
  a8:	30 e0       	ldi	r19, 0x00	; 0
  aa:	8b 81       	ldd	r24, Y+3	; 0x03
  ac:	88 2f       	mov	r24, r24
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	a9 01       	movw	r20, r18
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <DIO_GetPinVal+0xb4>
  b4:	55 95       	asr	r21
  b6:	47 95       	ror	r20
  b8:	8a 95       	dec	r24
  ba:	02 f4       	brpl	.+0      	; 0xbc <DIO_GetPinVal+0xbc>
  bc:	ca 01       	movw	r24, r20
  be:	81 70       	andi	r24, 0x01	; 1
  c0:	ec 81       	ldd	r30, Y+4	; 0x04
  c2:	fd 81       	ldd	r31, Y+5	; 0x05
  c4:	80 83       	st	Z, r24
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <DIO_GetPinVal+0xc8>
  c8:	e3 e3       	ldi	r30, 0x33	; 51
  ca:	f0 e0       	ldi	r31, 0x00	; 0
  cc:	80 81       	ld	r24, Z
  ce:	28 2f       	mov	r18, r24
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	8b 81       	ldd	r24, Y+3	; 0x03
  d4:	88 2f       	mov	r24, r24
  d6:	90 e0       	ldi	r25, 0x00	; 0
  d8:	a9 01       	movw	r20, r18
  da:	00 c0       	rjmp	.+0      	; 0xdc <DIO_GetPinVal+0xdc>
  dc:	55 95       	asr	r21
  de:	47 95       	ror	r20
  e0:	8a 95       	dec	r24
  e2:	02 f4       	brpl	.+0      	; 0xe4 <DIO_GetPinVal+0xe4>
  e4:	ca 01       	movw	r24, r20
  e6:	81 70       	andi	r24, 0x01	; 1
  e8:	ec 81       	ldd	r30, Y+4	; 0x04
  ea:	fd 81       	ldd	r31, Y+5	; 0x05
  ec:	80 83       	st	Z, r24
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <DIO_GetPinVal+0xf0>
  f0:	e0 e3       	ldi	r30, 0x30	; 48
  f2:	f0 e0       	ldi	r31, 0x00	; 0
  f4:	80 81       	ld	r24, Z
  f6:	28 2f       	mov	r18, r24
  f8:	30 e0       	ldi	r19, 0x00	; 0
  fa:	8b 81       	ldd	r24, Y+3	; 0x03
  fc:	88 2f       	mov	r24, r24
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	a9 01       	movw	r20, r18
 102:	00 c0       	rjmp	.+0      	; 0x104 <DIO_GetPinVal+0x104>
 104:	55 95       	asr	r21
 106:	47 95       	ror	r20
 108:	8a 95       	dec	r24
 10a:	02 f4       	brpl	.+0      	; 0x10c <DIO_GetPinVal+0x10c>
 10c:	ca 01       	movw	r24, r20
 10e:	81 70       	andi	r24, 0x01	; 1
 110:	ec 81       	ldd	r30, Y+4	; 0x04
 112:	fd 81       	ldd	r31, Y+5	; 0x05
 114:	80 83       	st	Z, r24
 116:	89 81       	ldd	r24, Y+1	; 0x01
 118:	27 96       	adiw	r28, 0x07	; 7
 11a:	0f b6       	in	r0, 0x3f	; 63
 11c:	f8 94       	cli
 11e:	de bf       	out	0x3e, r29	; 62
 120:	0f be       	out	0x3f, r0	; 63
 122:	cd bf       	out	0x3d, r28	; 61
 124:	cf 91       	pop	r28
 126:	df 91       	pop	r29
 128:	08 95       	ret

Disassembly of section .text.DIO_GetPortVal:

00000000 <DIO_GetPortVal>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/DIO_interface.h"
#include  "../inc/DIO_private.h"
#include "../inc/DIO_register.h"

status_t DIO_SetPortVal(Port_t Copy_Port, u8 Copy_u8Value) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_GetPortVal+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_GetPortVal+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <DIO_GetPortVal+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	7c 83       	std	Y+4, r23	; 0x04
	status_t Local_u8ErrorState = DIO_ok;
  12:	6b 83       	std	Y+3, r22	; 0x03
	if ((Copy_Port > DIO_PORTD) || (Copy_Port < DIO_PORTA)) {
  14:	19 82       	std	Y+1, r1	; 0x01
  16:	8a 81       	ldd	r24, Y+2	; 0x02
  18:	84 30       	cpi	r24, 0x04	; 4
		Local_u8ErrorState = DIO_SetErr;
  1a:	00 f0       	brcs	.+0      	; 0x1c <DIO_GetPortVal+0x1c>
  1c:	81 e0       	ldi	r24, 0x01	; 1
  1e:	89 83       	std	Y+1, r24	; 0x01
	} else {
		switch (Copy_Port) {
  20:	00 c0       	rjmp	.+0      	; 0x22 <DIO_GetPortVal+0x22>
  22:	8a 81       	ldd	r24, Y+2	; 0x02
  24:	28 2f       	mov	r18, r24
  26:	30 e0       	ldi	r19, 0x00	; 0
  28:	3e 83       	std	Y+6, r19	; 0x06
  2a:	2d 83       	std	Y+5, r18	; 0x05
  2c:	8d 81       	ldd	r24, Y+5	; 0x05
  2e:	9e 81       	ldd	r25, Y+6	; 0x06
  30:	81 30       	cpi	r24, 0x01	; 1
  32:	91 05       	cpc	r25, r1
  34:	01 f0       	breq	.+0      	; 0x36 <DIO_GetPortVal+0x36>
  36:	2d 81       	ldd	r18, Y+5	; 0x05
  38:	3e 81       	ldd	r19, Y+6	; 0x06
  3a:	22 30       	cpi	r18, 0x02	; 2
  3c:	31 05       	cpc	r19, r1
  3e:	04 f4       	brge	.+0      	; 0x40 <DIO_GetPortVal+0x40>
  40:	8d 81       	ldd	r24, Y+5	; 0x05
  42:	9e 81       	ldd	r25, Y+6	; 0x06
  44:	00 97       	sbiw	r24, 0x00	; 0
  46:	01 f0       	breq	.+0      	; 0x48 <DIO_GetPortVal+0x48>
  48:	00 c0       	rjmp	.+0      	; 0x4a <DIO_GetPortVal+0x4a>
  4a:	2d 81       	ldd	r18, Y+5	; 0x05
  4c:	3e 81       	ldd	r19, Y+6	; 0x06
  4e:	22 30       	cpi	r18, 0x02	; 2
  50:	31 05       	cpc	r19, r1
  52:	01 f0       	breq	.+0      	; 0x54 <DIO_GetPortVal+0x54>
  54:	8d 81       	ldd	r24, Y+5	; 0x05
  56:	9e 81       	ldd	r25, Y+6	; 0x06
  58:	83 30       	cpi	r24, 0x03	; 3
  5a:	91 05       	cpc	r25, r1
  5c:	01 f0       	breq	.+0      	; 0x5e <DIO_GetPortVal+0x5e>
		case DIO_PORTA:
			PORTA = Copy_u8Value;
  5e:	00 c0       	rjmp	.+0      	; 0x60 <DIO_GetPortVal+0x60>
  60:	e9 e3       	ldi	r30, 0x39	; 57
  62:	f0 e0       	ldi	r31, 0x00	; 0
  64:	80 81       	ld	r24, Z
  66:	eb 81       	ldd	r30, Y+3	; 0x03
			break;
		case DIO_PORTB:
			PORTB = Copy_u8Value;
  68:	fc 81       	ldd	r31, Y+4	; 0x04
  6a:	80 83       	st	Z, r24
  6c:	00 c0       	rjmp	.+0      	; 0x6e <DIO_GetPortVal+0x6e>
  6e:	e6 e3       	ldi	r30, 0x36	; 54
  70:	f0 e0       	ldi	r31, 0x00	; 0
			break;
		case DIO_PORTC:
			PORTC = Copy_u8Value;
  72:	80 81       	ld	r24, Z
  74:	eb 81       	ldd	r30, Y+3	; 0x03
  76:	fc 81       	ldd	r31, Y+4	; 0x04
  78:	80 83       	st	Z, r24
  7a:	00 c0       	rjmp	.+0      	; 0x7c <DIO_GetPortVal+0x7c>
			break;
		case DIO_PORTD:
			PORTD = Copy_u8Value;
  7c:	e3 e3       	ldi	r30, 0x33	; 51
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	80 81       	ld	r24, Z
  82:	eb 81       	ldd	r30, Y+3	; 0x03
			break;
		}
	}

	return Local_u8ErrorState;
  84:	fc 81       	ldd	r31, Y+4	; 0x04
}
  86:	80 83       	st	Z, r24
  88:	00 c0       	rjmp	.+0      	; 0x8a <DIO_GetPortVal+0x8a>
  8a:	e0 e3       	ldi	r30, 0x30	; 48
  8c:	f0 e0       	ldi	r31, 0x00	; 0
  8e:	80 81       	ld	r24, Z
  90:	eb 81       	ldd	r30, Y+3	; 0x03
  92:	fc 81       	ldd	r31, Y+4	; 0x04
  94:	80 83       	st	Z, r24
  96:	89 81       	ldd	r24, Y+1	; 0x01
  98:	26 96       	adiw	r28, 0x06	; 6
  9a:	0f b6       	in	r0, 0x3f	; 63
  9c:	f8 94       	cli
  9e:	de bf       	out	0x3e, r29	; 62
  a0:	0f be       	out	0x3f, r0	; 63
  a2:	cd bf       	out	0x3d, r28	; 61
  a4:	cf 91       	pop	r28
  a6:	df 91       	pop	r29
  a8:	08 95       	ret

ADC_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000504  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000008d3  00000000  00000000  00000538  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.Global_PvNotifacation 00000002  00000000  00000000  00000e0b  2**0
                  ALLOC
  6 .bss.Global_u16PuReading 00000002  00000000  00000000  00000e0b  2**0
                  ALLOC
  7 .text.ADC_voidInit 00000050  00000000  00000000  00000e0b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.ADC_u8StartConversionSynchronus 000000da  00000000  00000000  00000e5b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.ADC_u8StartConversionASynchronus 00000078  00000000  00000000  00000f35  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.__vector_16 0000006e  00000000  00000000  00000fad  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.ADC_voidInit:

00000000 <ADC_voidInit>:
#include "../inc/ADC_interface.h"
#include "../inc/ADC_register.h"
#include "../inc/ADC_config.h"
#include "../inc/ADC_private.h"

void ADC_voidInit(void) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	/*PRE-SCALER SELECTION*/
	ADCSRA_Reg->ADPS = DESIRED_PRE_SCALER;
   8:	e6 e2       	ldi	r30, 0x26	; 38
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	88 7f       	andi	r24, 0xF8	; 248
  10:	83 60       	ori	r24, 0x03	; 3
  12:	80 83       	st	Z, r24

	/*Choosing the voltage reference*/
	ADMUX_Reg->REFS = DESIRED_VOLTAGE_REF;
  14:	e7 e2       	ldi	r30, 0x27	; 39
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	8f 73       	andi	r24, 0x3F	; 63
  1c:	80 64       	ori	r24, 0x40	; 64
  1e:	80 83       	st	Z, r24
	/*choose the Resolution*/
	ADMUX_Reg->ADLAR = RIGHT;
  20:	e7 e2       	ldi	r30, 0x27	; 39
  22:	f0 e0       	ldi	r31, 0x00	; 0
  24:	80 81       	ld	r24, Z
  26:	8f 7d       	andi	r24, 0xDF	; 223
  28:	80 83       	st	Z, r24

#ifdef AUTO_TREGERED

	ADCSRA_Reg->ADATE=ENABLE;
  2a:	e6 e2       	ldi	r30, 0x26	; 38
  2c:	f0 e0       	ldi	r31, 0x00	; 0
  2e:	80 81       	ld	r24, Z
  30:	80 62       	ori	r24, 0x20	; 32
  32:	80 83       	st	Z, r24

	ADC_SFIOR_Reg->ADTS  =  AUTO_TRIGER_SOURCE;
  34:	e0 e5       	ldi	r30, 0x50	; 80
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	80 81       	ld	r24, Z
  3a:	8f 71       	andi	r24, 0x1F	; 31
  3c:	80 68       	ori	r24, 0x80	; 128
  3e:	80 83       	st	Z, r24

#endif
	/*ENABLE THE ADC*/
	ADCSRA_Reg->ADEN = ENABLE;
  40:	e6 e2       	ldi	r30, 0x26	; 38
  42:	f0 e0       	ldi	r31, 0x00	; 0
  44:	80 81       	ld	r24, Z
  46:	80 68       	ori	r24, 0x80	; 128
  48:	80 83       	st	Z, r24

}
  4a:	cf 91       	pop	r28
  4c:	df 91       	pop	r29
  4e:	08 95       	ret

Disassembly of section .text.ADC_u8StartConversionSynchronus:

00000000 <ADC_u8StartConversionSynchronus>:
#include "../inc/ADC_interface.h"
#include "../inc/ADC_register.h"
#include "../inc/ADC_config.h"
#include "../inc/ADC_private.h"

void ADC_voidInit(void) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	/*PRE-SCALER SELECTION*/
	ADCSRA_Reg->ADPS = DESIRED_PRE_SCALER;
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61

	/*Choosing the voltage reference*/
	ADMUX_Reg->REFS = DESIRED_VOLTAGE_REF;
  14:	8e 83       	std	Y+6, r24	; 0x06
  16:	78 87       	std	Y+8, r23	; 0x08
  18:	6f 83       	std	Y+7, r22	; 0x07
  1a:	1d 82       	std	Y+5, r1	; 0x05
  1c:	19 82       	std	Y+1, r1	; 0x01
  1e:	1a 82       	std	Y+2, r1	; 0x02
	/*choose the Resolution*/
	ADMUX_Reg->ADLAR = RIGHT;
  20:	1b 82       	std	Y+3, r1	; 0x03
  22:	1c 82       	std	Y+4, r1	; 0x04
  24:	8f 81       	ldd	r24, Y+7	; 0x07
  26:	98 85       	ldd	r25, Y+8	; 0x08
  28:	00 97       	sbiw	r24, 0x00	; 0

#ifdef AUTO_TREGERED

	ADCSRA_Reg->ADATE=ENABLE;
  2a:	01 f4       	brne	.+0      	; 0x2c <ADC_u8StartConversionSynchronus+0x2c>
  2c:	81 e0       	ldi	r24, 0x01	; 1
  2e:	8d 83       	std	Y+5, r24	; 0x05
  30:	00 c0       	rjmp	.+0      	; 0x32 <ADC_u8StartConversionSynchronus+0x32>
  32:	8e 81       	ldd	r24, Y+6	; 0x06

	ADC_SFIOR_Reg->ADTS  =  AUTO_TRIGER_SOURCE;
  34:	88 30       	cpi	r24, 0x08	; 8
  36:	00 f0       	brcs	.+0      	; 0x38 <ADC_u8StartConversionSynchronus+0x38>
  38:	82 e0       	ldi	r24, 0x02	; 2
  3a:	8d 83       	std	Y+5, r24	; 0x05
  3c:	00 c0       	rjmp	.+0      	; 0x3e <ADC_u8StartConversionSynchronus+0x3e>
  3e:	e7 e2       	ldi	r30, 0x27	; 39

#endif
	/*ENABLE THE ADC*/
	ADCSRA_Reg->ADEN = ENABLE;
  40:	f0 e0       	ldi	r31, 0x00	; 0
  42:	8e 81       	ldd	r24, Y+6	; 0x06
  44:	8f 71       	andi	r24, 0x1F	; 31
  46:	98 2f       	mov	r25, r24
  48:	9f 71       	andi	r25, 0x1F	; 31

}
  4a:	80 81       	ld	r24, Z
  4c:	80 7e       	andi	r24, 0xE0	; 224
  4e:	89 2b       	or	r24, r25
  50:	80 83       	st	Z, r24
  52:	00 c0       	rjmp	.+0      	; 0x54 <ADC_u8StartConversionSynchronus+0x54>
  54:	89 81       	ldd	r24, Y+1	; 0x01
  56:	9a 81       	ldd	r25, Y+2	; 0x02
  58:	ab 81       	ldd	r26, Y+3	; 0x03
  5a:	bc 81       	ldd	r27, Y+4	; 0x04
  5c:	01 96       	adiw	r24, 0x01	; 1
  5e:	a1 1d       	adc	r26, r1
  60:	b1 1d       	adc	r27, r1
  62:	89 83       	std	Y+1, r24	; 0x01
  64:	9a 83       	std	Y+2, r25	; 0x02
  66:	ab 83       	std	Y+3, r26	; 0x03
  68:	bc 83       	std	Y+4, r27	; 0x04
  6a:	e6 e2       	ldi	r30, 0x26	; 38
  6c:	f0 e0       	ldi	r31, 0x00	; 0
  6e:	80 81       	ld	r24, Z
  70:	80 71       	andi	r24, 0x10	; 16
  72:	88 23       	and	r24, r24
  74:	01 f4       	brne	.+0      	; 0x76 <ADC_u8StartConversionSynchronus+0x76>
  76:	89 81       	ldd	r24, Y+1	; 0x01
  78:	9a 81       	ldd	r25, Y+2	; 0x02
  7a:	ab 81       	ldd	r26, Y+3	; 0x03
  7c:	bc 81       	ldd	r27, Y+4	; 0x04
  7e:	84 3f       	cpi	r24, 0xF4	; 244
  80:	21 e0       	ldi	r18, 0x01	; 1
  82:	92 07       	cpc	r25, r18
  84:	20 e0       	ldi	r18, 0x00	; 0
  86:	a2 07       	cpc	r26, r18
  88:	20 e0       	ldi	r18, 0x00	; 0
  8a:	b2 07       	cpc	r27, r18
  8c:	00 f0       	brcs	.+0      	; 0x8e <ADC_u8StartConversionSynchronus+0x8e>
  8e:	89 81       	ldd	r24, Y+1	; 0x01
  90:	9a 81       	ldd	r25, Y+2	; 0x02
  92:	ab 81       	ldd	r26, Y+3	; 0x03
  94:	bc 81       	ldd	r27, Y+4	; 0x04
  96:	84 3f       	cpi	r24, 0xF4	; 244
  98:	21 e0       	ldi	r18, 0x01	; 1
  9a:	92 07       	cpc	r25, r18
  9c:	20 e0       	ldi	r18, 0x00	; 0
  9e:	a2 07       	cpc	r26, r18
  a0:	20 e0       	ldi	r18, 0x00	; 0
  a2:	b2 07       	cpc	r27, r18
  a4:	01 f4       	brne	.+0      	; 0xa6 <ADC_u8StartConversionSynchronus+0xa6>
  a6:	83 e0       	ldi	r24, 0x03	; 3
  a8:	8d 83       	std	Y+5, r24	; 0x05
  aa:	00 c0       	rjmp	.+0      	; 0xac <ADC_u8StartConversionSynchronus+0xac>
  ac:	e6 e2       	ldi	r30, 0x26	; 38
  ae:	f0 e0       	ldi	r31, 0x00	; 0
  b0:	80 81       	ld	r24, Z
  b2:	80 61       	ori	r24, 0x10	; 16
  b4:	80 83       	st	Z, r24
  b6:	e4 e2       	ldi	r30, 0x24	; 36
  b8:	f0 e0       	ldi	r31, 0x00	; 0
  ba:	80 81       	ld	r24, Z
  bc:	91 81       	ldd	r25, Z+1	; 0x01
  be:	ef 81       	ldd	r30, Y+7	; 0x07
  c0:	f8 85       	ldd	r31, Y+8	; 0x08
  c2:	91 83       	std	Z+1, r25	; 0x01
  c4:	80 83       	st	Z, r24
  c6:	8d 81       	ldd	r24, Y+5	; 0x05
  c8:	28 96       	adiw	r28, 0x08	; 8
  ca:	0f b6       	in	r0, 0x3f	; 63
  cc:	f8 94       	cli
  ce:	de bf       	out	0x3e, r29	; 62
  d0:	0f be       	out	0x3f, r0	; 63
  d2:	cd bf       	out	0x3d, r28	; 61
  d4:	cf 91       	pop	r28
  d6:	df 91       	pop	r29
  d8:	08 95       	ret

Disassembly of section .text.ADC_u8StartConversionASynchronus:

00000000 <ADC_u8StartConversionASynchronus>:
#include "../inc/ADC_interface.h"
#include "../inc/ADC_register.h"
#include "../inc/ADC_config.h"
#include "../inc/ADC_private.h"

void ADC_voidInit(void) {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <ADC_u8StartConversionASynchronus+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <ADC_u8StartConversionASynchronus+0x8>
	/*PRE-SCALER SELECTION*/
	ADCSRA_Reg->ADPS = DESIRED_PRE_SCALER;
   8:	00 d0       	rcall	.+0      	; 0xa <ADC_u8StartConversionASynchronus+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	7c 83       	std	Y+4, r23	; 0x04
  12:	6b 83       	std	Y+3, r22	; 0x03

	/*Choosing the voltage reference*/
	ADMUX_Reg->REFS = DESIRED_VOLTAGE_REF;
  14:	5e 83       	std	Y+6, r21	; 0x06
  16:	4d 83       	std	Y+5, r20	; 0x05
  18:	19 82       	std	Y+1, r1	; 0x01
  1a:	8d 81       	ldd	r24, Y+5	; 0x05
  1c:	9e 81       	ldd	r25, Y+6	; 0x06
  1e:	00 97       	sbiw	r24, 0x00	; 0
	/*choose the Resolution*/
	ADMUX_Reg->ADLAR = RIGHT;
  20:	01 f4       	brne	.+0      	; 0x22 <ADC_u8StartConversionASynchronus+0x22>
  22:	81 e0       	ldi	r24, 0x01	; 1
  24:	89 83       	std	Y+1, r24	; 0x01
  26:	00 c0       	rjmp	.+0      	; 0x28 <ADC_u8StartConversionASynchronus+0x28>
  28:	8a 81       	ldd	r24, Y+2	; 0x02

#ifdef AUTO_TREGERED

	ADCSRA_Reg->ADATE=ENABLE;
  2a:	88 30       	cpi	r24, 0x08	; 8
  2c:	00 f0       	brcs	.+0      	; 0x2e <ADC_u8StartConversionASynchronus+0x2e>
  2e:	82 e0       	ldi	r24, 0x02	; 2
  30:	89 83       	std	Y+1, r24	; 0x01
  32:	00 c0       	rjmp	.+0      	; 0x34 <ADC_u8StartConversionASynchronus+0x34>

	ADC_SFIOR_Reg->ADTS  =  AUTO_TRIGER_SOURCE;
  34:	8b 81       	ldd	r24, Y+3	; 0x03
  36:	9c 81       	ldd	r25, Y+4	; 0x04
  38:	00 97       	sbiw	r24, 0x00	; 0
  3a:	01 f4       	brne	.+0      	; 0x3c <ADC_u8StartConversionASynchronus+0x3c>
  3c:	81 e0       	ldi	r24, 0x01	; 1
  3e:	89 83       	std	Y+1, r24	; 0x01

#endif
	/*ENABLE THE ADC*/
	ADCSRA_Reg->ADEN = ENABLE;
  40:	00 c0       	rjmp	.+0      	; 0x42 <ADC_u8StartConversionASynchronus+0x42>
  42:	8b 81       	ldd	r24, Y+3	; 0x03
  44:	9c 81       	ldd	r25, Y+4	; 0x04
  46:	90 93 00 00 	sts	0x0000, r25

}
  4a:	80 93 00 00 	sts	0x0000, r24
  4e:	8d 81       	ldd	r24, Y+5	; 0x05
  50:	9e 81       	ldd	r25, Y+6	; 0x06
  52:	90 93 00 00 	sts	0x0000, r25
  56:	80 93 00 00 	sts	0x0000, r24
  5a:	e6 e2       	ldi	r30, 0x26	; 38
  5c:	f0 e0       	ldi	r31, 0x00	; 0
  5e:	80 81       	ld	r24, Z
  60:	88 60       	ori	r24, 0x08	; 8
  62:	80 83       	st	Z, r24
  64:	89 81       	ldd	r24, Y+1	; 0x01
  66:	26 96       	adiw	r28, 0x06	; 6
  68:	0f b6       	in	r0, 0x3f	; 63
  6a:	f8 94       	cli
  6c:	de bf       	out	0x3e, r29	; 62
  6e:	0f be       	out	0x3f, r0	; 63
  70:	cd bf       	out	0x3d, r28	; 61
  72:	cf 91       	pop	r28
  74:	df 91       	pop	r29
  76:	08 95       	ret

Disassembly of section .text.__vector_16:

00000000 <__vector_16>:
#include "../inc/ADC_interface.h"
#include "../inc/ADC_register.h"
#include "../inc/ADC_config.h"
#include "../inc/ADC_private.h"

void ADC_voidInit(void) {
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
	/*PRE-SCALER SELECTION*/
	ADCSRA_Reg->ADPS = DESIRED_PRE_SCALER;
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22

	/*Choosing the voltage reference*/
	ADMUX_Reg->REFS = DESIRED_VOLTAGE_REF;
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
	/*choose the Resolution*/
	ADMUX_Reg->ADLAR = RIGHT;
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62

#ifdef AUTO_TREGERED

	ADCSRA_Reg->ADATE=ENABLE;
  2a:	a0 91 00 00 	lds	r26, 0x0000
  2e:	b0 91 00 00 	lds	r27, 0x0000
  32:	e4 e2       	ldi	r30, 0x24	; 36

	ADC_SFIOR_Reg->ADTS  =  AUTO_TRIGER_SOURCE;
  34:	f0 e0       	ldi	r31, 0x00	; 0
  36:	80 81       	ld	r24, Z
  38:	91 81       	ldd	r25, Z+1	; 0x01
  3a:	8d 93       	st	X+, r24
  3c:	9c 93       	st	X, r25
  3e:	e0 91 00 00 	lds	r30, 0x0000

#endif
	/*ENABLE THE ADC*/
	ADCSRA_Reg->ADEN = ENABLE;
  42:	f0 91 00 00 	lds	r31, 0x0000
  46:	09 95       	icall
  48:	cf 91       	pop	r28

}
  4a:	df 91       	pop	r29
  4c:	ff 91       	pop	r31
  4e:	ef 91       	pop	r30
  50:	bf 91       	pop	r27
  52:	af 91       	pop	r26
  54:	9f 91       	pop	r25
  56:	8f 91       	pop	r24
  58:	7f 91       	pop	r23
  5a:	6f 91       	pop	r22
  5c:	5f 91       	pop	r21
  5e:	4f 91       	pop	r20
  60:	3f 91       	pop	r19
  62:	2f 91       	pop	r18
  64:	0f 90       	pop	r0
  66:	0f be       	out	0x3f, r0	; 63
  68:	0f 90       	pop	r0
  6a:	1f 90       	pop	r1
  6c:	18 95       	reti

CLCD_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000a20  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000e62  00000000  00000000  00000a54  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.CLCD_voidSendCommand 0000013c  00000000  00000000  000018b6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.CLCD_voidInit 0000011c  00000000  00000000  000019f2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.CLCD_voidSendData 0000013c  00000000  00000000  00001b0e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.CLCD_voidSendString 00000052  00000000  00000000  00001c4a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.CLCD_voidGoToXY 0000003c  00000000  00000000  00001c9c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.CLCD_voidWriteNumber 0000011e  00000000  00000000  00001cd8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.CLCD_voidWriteSpecialChar 00000082  00000000  00000000  00001df6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.CLCD_voidSendCommand:

00000000 <CLCD_voidSendCommand>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/CLCD_interface.h"
#include "../../../MCAL/DIO/inc/DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2f 97       	sbiw	r28, 0x0f	; 15
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8f 87       	std	Y+15, r24	; 0x0f
	/*Setting RS pin to low*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
  16:	83 e0       	ldi	r24, 0x03	; 3
  18:	60 e0       	ldi	r22, 0x00	; 0
  1a:	40 e0       	ldi	r20, 0x00	; 0
  1c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
/*Setting RW pin low for write*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
  20:	83 e0       	ldi	r24, 0x03	; 3
  22:	61 e0       	ldi	r22, 0x01	; 1
  24:	40 e0       	ldi	r20, 0x00	; 0
  26:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>

/*Set command data pins*/
DIO_SetPortVal(CLCD_DATA_PORT,copy_u8Command);
  2a:	82 e0       	ldi	r24, 0x02	; 2
  2c:	6f 85       	ldd	r22, Y+15	; 0x0f
  2e:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>

/*Send Enable pulse*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
  32:	83 e0       	ldi	r24, 0x03	; 3
  34:	62 e0       	ldi	r22, 0x02	; 2
  36:	41 e0       	ldi	r20, 0x01	; 1
  38:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	90 e0       	ldi	r25, 0x00	; 0
  40:	a0 e0       	ldi	r26, 0x00	; 0
  42:	b0 e4       	ldi	r27, 0x40	; 64
  44:	8b 87       	std	Y+11, r24	; 0x0b
  46:	9c 87       	std	Y+12, r25	; 0x0c
  48:	ad 87       	std	Y+13, r26	; 0x0d
  4a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  4c:	6b 85       	ldd	r22, Y+11	; 0x0b
  4e:	7c 85       	ldd	r23, Y+12	; 0x0c
  50:	8d 85       	ldd	r24, Y+13	; 0x0d
  52:	9e 85       	ldd	r25, Y+14	; 0x0e
  54:	20 e0       	ldi	r18, 0x00	; 0
  56:	30 e0       	ldi	r19, 0x00	; 0
  58:	4a ef       	ldi	r20, 0xFA	; 250
  5a:	54 e4       	ldi	r21, 0x44	; 68
  5c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
  60:	dc 01       	movw	r26, r24
  62:	cb 01       	movw	r24, r22
  64:	8f 83       	std	Y+7, r24	; 0x07
  66:	98 87       	std	Y+8, r25	; 0x08
  68:	a9 87       	std	Y+9, r26	; 0x09
  6a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
  6c:	6f 81       	ldd	r22, Y+7	; 0x07
  6e:	78 85       	ldd	r23, Y+8	; 0x08
  70:	89 85       	ldd	r24, Y+9	; 0x09
  72:	9a 85       	ldd	r25, Y+10	; 0x0a
  74:	20 e0       	ldi	r18, 0x00	; 0
  76:	30 e0       	ldi	r19, 0x00	; 0
  78:	40 e8       	ldi	r20, 0x80	; 128
  7a:	5f e3       	ldi	r21, 0x3F	; 63
  7c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
  80:	88 23       	and	r24, r24
  82:	04 f4       	brge	.+0      	; 0x84 <CLCD_voidSendCommand+0x84>
		__ticks = 1;
  84:	81 e0       	ldi	r24, 0x01	; 1
  86:	90 e0       	ldi	r25, 0x00	; 0
  88:	9e 83       	std	Y+6, r25	; 0x06
  8a:	8d 83       	std	Y+5, r24	; 0x05
  8c:	00 c0       	rjmp	.+0      	; 0x8e <CLCD_voidSendCommand+0x8e>
	else if (__tmp > 65535)
  8e:	6f 81       	ldd	r22, Y+7	; 0x07
  90:	78 85       	ldd	r23, Y+8	; 0x08
  92:	89 85       	ldd	r24, Y+9	; 0x09
  94:	9a 85       	ldd	r25, Y+10	; 0x0a
  96:	20 e0       	ldi	r18, 0x00	; 0
  98:	3f ef       	ldi	r19, 0xFF	; 255
  9a:	4f e7       	ldi	r20, 0x7F	; 127
  9c:	57 e4       	ldi	r21, 0x47	; 71
  9e:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
  a2:	18 16       	cp	r1, r24
  a4:	04 f4       	brge	.+0      	; 0xa6 <CLCD_voidSendCommand+0xa6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  a6:	6b 85       	ldd	r22, Y+11	; 0x0b
  a8:	7c 85       	ldd	r23, Y+12	; 0x0c
  aa:	8d 85       	ldd	r24, Y+13	; 0x0d
  ac:	9e 85       	ldd	r25, Y+14	; 0x0e
  ae:	20 e0       	ldi	r18, 0x00	; 0
  b0:	30 e0       	ldi	r19, 0x00	; 0
  b2:	40 e2       	ldi	r20, 0x20	; 32
  b4:	51 e4       	ldi	r21, 0x41	; 65
  b6:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
  ba:	dc 01       	movw	r26, r24
  bc:	cb 01       	movw	r24, r22
  be:	bc 01       	movw	r22, r24
  c0:	cd 01       	movw	r24, r26
  c2:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
  c6:	dc 01       	movw	r26, r24
  c8:	cb 01       	movw	r24, r22
  ca:	9e 83       	std	Y+6, r25	; 0x06
  cc:	8d 83       	std	Y+5, r24	; 0x05
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <CLCD_voidSendCommand+0xd0>
  d0:	88 ec       	ldi	r24, 0xC8	; 200
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	9c 83       	std	Y+4, r25	; 0x04
  d6:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  d8:	8b 81       	ldd	r24, Y+3	; 0x03
  da:	9c 81       	ldd	r25, Y+4	; 0x04
  dc:	01 97       	sbiw	r24, 0x01	; 1
  de:	01 f4       	brne	.+0      	; 0xe0 <CLCD_voidSendCommand+0xe0>
  e0:	9c 83       	std	Y+4, r25	; 0x04
  e2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  e4:	8d 81       	ldd	r24, Y+5	; 0x05
  e6:	9e 81       	ldd	r25, Y+6	; 0x06
  e8:	01 97       	sbiw	r24, 0x01	; 1
  ea:	9e 83       	std	Y+6, r25	; 0x06
  ec:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  ee:	8d 81       	ldd	r24, Y+5	; 0x05
  f0:	9e 81       	ldd	r25, Y+6	; 0x06
  f2:	00 97       	sbiw	r24, 0x00	; 0
  f4:	01 f4       	brne	.+0      	; 0xf6 <CLCD_voidSendCommand+0xf6>
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <CLCD_voidSendCommand+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
  f8:	6f 81       	ldd	r22, Y+7	; 0x07
  fa:	78 85       	ldd	r23, Y+8	; 0x08
  fc:	89 85       	ldd	r24, Y+9	; 0x09
  fe:	9a 85       	ldd	r25, Y+10	; 0x0a
 100:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
 104:	dc 01       	movw	r26, r24
 106:	cb 01       	movw	r24, r22
 108:	9e 83       	std	Y+6, r25	; 0x06
 10a:	8d 83       	std	Y+5, r24	; 0x05
 10c:	8d 81       	ldd	r24, Y+5	; 0x05
 10e:	9e 81       	ldd	r25, Y+6	; 0x06
 110:	9a 83       	std	Y+2, r25	; 0x02
 112:	89 83       	std	Y+1, r24	; 0x01
 114:	89 81       	ldd	r24, Y+1	; 0x01
 116:	9a 81       	ldd	r25, Y+2	; 0x02
 118:	01 97       	sbiw	r24, 0x01	; 1
 11a:	01 f4       	brne	.+0      	; 0x11c <CLCD_voidSendCommand+0x11c>
 11c:	9a 83       	std	Y+2, r25	; 0x02
 11e:	89 83       	std	Y+1, r24	; 0x01
_delay_ms(2);
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_LOW);
 120:	83 e0       	ldi	r24, 0x03	; 3
 122:	62 e0       	ldi	r22, 0x02	; 2
 124:	40 e0       	ldi	r20, 0x00	; 0
 126:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendCommand>
}
 12a:	2f 96       	adiw	r28, 0x0f	; 15
 12c:	0f b6       	in	r0, 0x3f	; 63
 12e:	f8 94       	cli
 130:	de bf       	out	0x3e, r29	; 62
 132:	0f be       	out	0x3f, r0	; 63
 134:	cd bf       	out	0x3d, r28	; 61
 136:	cf 91       	pop	r28
 138:	df 91       	pop	r29
 13a:	08 95       	ret

Disassembly of section .text.CLCD_voidInit:

00000000 <CLCD_voidInit>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/CLCD_interface.h"
#include "../../../MCAL/DIO/inc/DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2e 97       	sbiw	r28, 0x0e	; 14
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	80 e0       	ldi	r24, 0x00	; 0
	/*Setting RS pin to low*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	a0 e2       	ldi	r26, 0x20	; 32
  1a:	b2 e4       	ldi	r27, 0x42	; 66
  1c:	8b 87       	std	Y+11, r24	; 0x0b
  1e:	9c 87       	std	Y+12, r25	; 0x0c
/*Setting RW pin low for write*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
  20:	ad 87       	std	Y+13, r26	; 0x0d
  22:	be 87       	std	Y+14, r27	; 0x0e
  24:	6b 85       	ldd	r22, Y+11	; 0x0b
  26:	7c 85       	ldd	r23, Y+12	; 0x0c
  28:	8d 85       	ldd	r24, Y+13	; 0x0d

/*Set command data pins*/
DIO_SetPortVal(CLCD_DATA_PORT,copy_u8Command);
  2a:	9e 85       	ldd	r25, Y+14	; 0x0e
  2c:	20 e0       	ldi	r18, 0x00	; 0
  2e:	30 e0       	ldi	r19, 0x00	; 0
  30:	4a ef       	ldi	r20, 0xFA	; 250

/*Send Enable pulse*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
  32:	54 e4       	ldi	r21, 0x44	; 68
  34:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
  38:	dc 01       	movw	r26, r24
  3a:	cb 01       	movw	r24, r22
  3c:	8f 83       	std	Y+7, r24	; 0x07
  3e:	98 87       	std	Y+8, r25	; 0x08
  40:	a9 87       	std	Y+9, r26	; 0x09
  42:	ba 87       	std	Y+10, r27	; 0x0a
  44:	6f 81       	ldd	r22, Y+7	; 0x07
  46:	78 85       	ldd	r23, Y+8	; 0x08
  48:	89 85       	ldd	r24, Y+9	; 0x09
  4a:	9a 85       	ldd	r25, Y+10	; 0x0a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  4c:	20 e0       	ldi	r18, 0x00	; 0
  4e:	30 e0       	ldi	r19, 0x00	; 0
  50:	40 e8       	ldi	r20, 0x80	; 128
  52:	5f e3       	ldi	r21, 0x3F	; 63
  54:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
  58:	88 23       	and	r24, r24
  5a:	04 f4       	brge	.+0      	; 0x5c <CLCD_voidInit+0x5c>
  5c:	81 e0       	ldi	r24, 0x01	; 1
  5e:	90 e0       	ldi	r25, 0x00	; 0
  60:	9e 83       	std	Y+6, r25	; 0x06
  62:	8d 83       	std	Y+5, r24	; 0x05
  64:	00 c0       	rjmp	.+0      	; 0x66 <CLCD_voidInit+0x66>
  66:	6f 81       	ldd	r22, Y+7	; 0x07
  68:	78 85       	ldd	r23, Y+8	; 0x08
  6a:	89 85       	ldd	r24, Y+9	; 0x09
	if (__tmp < 1.0)
  6c:	9a 85       	ldd	r25, Y+10	; 0x0a
  6e:	20 e0       	ldi	r18, 0x00	; 0
  70:	3f ef       	ldi	r19, 0xFF	; 255
  72:	4f e7       	ldi	r20, 0x7F	; 127
  74:	57 e4       	ldi	r21, 0x47	; 71
  76:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
  7a:	18 16       	cp	r1, r24
  7c:	04 f4       	brge	.+0      	; 0x7e <CLCD_voidInit+0x7e>
  7e:	6b 85       	ldd	r22, Y+11	; 0x0b
  80:	7c 85       	ldd	r23, Y+12	; 0x0c
  82:	8d 85       	ldd	r24, Y+13	; 0x0d
		__ticks = 1;
  84:	9e 85       	ldd	r25, Y+14	; 0x0e
  86:	20 e0       	ldi	r18, 0x00	; 0
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	40 e2       	ldi	r20, 0x20	; 32
  8c:	51 e4       	ldi	r21, 0x41	; 65
	else if (__tmp > 65535)
  8e:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
  92:	dc 01       	movw	r26, r24
  94:	cb 01       	movw	r24, r22
  96:	bc 01       	movw	r22, r24
  98:	cd 01       	movw	r24, r26
  9a:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
  9e:	dc 01       	movw	r26, r24
  a0:	cb 01       	movw	r24, r22
  a2:	9e 83       	std	Y+6, r25	; 0x06
  a4:	8d 83       	std	Y+5, r24	; 0x05
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <CLCD_voidInit+0xa8>
  a8:	88 ec       	ldi	r24, 0xC8	; 200
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	9c 83       	std	Y+4, r25	; 0x04
  ae:	8b 83       	std	Y+3, r24	; 0x03
  b0:	8b 81       	ldd	r24, Y+3	; 0x03
  b2:	9c 81       	ldd	r25, Y+4	; 0x04
  b4:	01 97       	sbiw	r24, 0x01	; 1
  b6:	01 f4       	brne	.+0      	; 0xb8 <CLCD_voidInit+0xb8>
  b8:	9c 83       	std	Y+4, r25	; 0x04
  ba:	8b 83       	std	Y+3, r24	; 0x03
  bc:	8d 81       	ldd	r24, Y+5	; 0x05
  be:	9e 81       	ldd	r25, Y+6	; 0x06
  c0:	01 97       	sbiw	r24, 0x01	; 1
  c2:	9e 83       	std	Y+6, r25	; 0x06
  c4:	8d 83       	std	Y+5, r24	; 0x05
  c6:	8d 81       	ldd	r24, Y+5	; 0x05
  c8:	9e 81       	ldd	r25, Y+6	; 0x06
  ca:	00 97       	sbiw	r24, 0x00	; 0
  cc:	01 f4       	brne	.+0      	; 0xce <CLCD_voidInit+0xce>
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <CLCD_voidInit+0xd0>
  d0:	6f 81       	ldd	r22, Y+7	; 0x07
  d2:	78 85       	ldd	r23, Y+8	; 0x08
  d4:	89 85       	ldd	r24, Y+9	; 0x09
  d6:	9a 85       	ldd	r25, Y+10	; 0x0a
  d8:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
  dc:	dc 01       	movw	r26, r24
  de:	cb 01       	movw	r24, r22
  e0:	9e 83       	std	Y+6, r25	; 0x06
  e2:	8d 83       	std	Y+5, r24	; 0x05
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  e4:	8d 81       	ldd	r24, Y+5	; 0x05
  e6:	9e 81       	ldd	r25, Y+6	; 0x06
  e8:	9a 83       	std	Y+2, r25	; 0x02
  ea:	89 83       	std	Y+1, r24	; 0x01
  ec:	89 81       	ldd	r24, Y+1	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  ee:	9a 81       	ldd	r25, Y+2	; 0x02
  f0:	01 97       	sbiw	r24, 0x01	; 1
  f2:	01 f4       	brne	.+0      	; 0xf4 <CLCD_voidInit+0xf4>
  f4:	9a 83       	std	Y+2, r25	; 0x02
  f6:	89 83       	std	Y+1, r24	; 0x01
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
  f8:	88 e3       	ldi	r24, 0x38	; 56
  fa:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
  fe:	8c e0       	ldi	r24, 0x0C	; 12
 100:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
 104:	81 e0       	ldi	r24, 0x01	; 1
 106:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidInit>
 10a:	2e 96       	adiw	r28, 0x0e	; 14
 10c:	0f b6       	in	r0, 0x3f	; 63
 10e:	f8 94       	cli
 110:	de bf       	out	0x3e, r29	; 62
 112:	0f be       	out	0x3f, r0	; 63
 114:	cd bf       	out	0x3d, r28	; 61
 116:	cf 91       	pop	r28
 118:	df 91       	pop	r29
 11a:	08 95       	ret

Disassembly of section .text.CLCD_voidSendData:

00000000 <CLCD_voidSendData>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/CLCD_interface.h"
#include "../../../MCAL/DIO/inc/DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2f 97       	sbiw	r28, 0x0f	; 15
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8f 87       	std	Y+15, r24	; 0x0f
	/*Setting RS pin to low*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
  16:	83 e0       	ldi	r24, 0x03	; 3
  18:	60 e0       	ldi	r22, 0x00	; 0
  1a:	41 e0       	ldi	r20, 0x01	; 1
  1c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
/*Setting RW pin low for write*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
  20:	83 e0       	ldi	r24, 0x03	; 3
  22:	61 e0       	ldi	r22, 0x01	; 1
  24:	40 e0       	ldi	r20, 0x00	; 0
  26:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>

/*Set command data pins*/
DIO_SetPortVal(CLCD_DATA_PORT,copy_u8Command);
  2a:	82 e0       	ldi	r24, 0x02	; 2
  2c:	6f 85       	ldd	r22, Y+15	; 0x0f
  2e:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>

/*Send Enable pulse*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
  32:	83 e0       	ldi	r24, 0x03	; 3
  34:	62 e0       	ldi	r22, 0x02	; 2
  36:	41 e0       	ldi	r20, 0x01	; 1
  38:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	90 e0       	ldi	r25, 0x00	; 0
  40:	a0 e0       	ldi	r26, 0x00	; 0
  42:	b0 e4       	ldi	r27, 0x40	; 64
  44:	8b 87       	std	Y+11, r24	; 0x0b
  46:	9c 87       	std	Y+12, r25	; 0x0c
  48:	ad 87       	std	Y+13, r26	; 0x0d
  4a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  4c:	6b 85       	ldd	r22, Y+11	; 0x0b
  4e:	7c 85       	ldd	r23, Y+12	; 0x0c
  50:	8d 85       	ldd	r24, Y+13	; 0x0d
  52:	9e 85       	ldd	r25, Y+14	; 0x0e
  54:	20 e0       	ldi	r18, 0x00	; 0
  56:	30 e0       	ldi	r19, 0x00	; 0
  58:	4a ef       	ldi	r20, 0xFA	; 250
  5a:	54 e4       	ldi	r21, 0x44	; 68
  5c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
  60:	dc 01       	movw	r26, r24
  62:	cb 01       	movw	r24, r22
  64:	8f 83       	std	Y+7, r24	; 0x07
  66:	98 87       	std	Y+8, r25	; 0x08
  68:	a9 87       	std	Y+9, r26	; 0x09
  6a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
  6c:	6f 81       	ldd	r22, Y+7	; 0x07
  6e:	78 85       	ldd	r23, Y+8	; 0x08
  70:	89 85       	ldd	r24, Y+9	; 0x09
  72:	9a 85       	ldd	r25, Y+10	; 0x0a
  74:	20 e0       	ldi	r18, 0x00	; 0
  76:	30 e0       	ldi	r19, 0x00	; 0
  78:	40 e8       	ldi	r20, 0x80	; 128
  7a:	5f e3       	ldi	r21, 0x3F	; 63
  7c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
  80:	88 23       	and	r24, r24
  82:	04 f4       	brge	.+0      	; 0x84 <CLCD_voidSendData+0x84>
		__ticks = 1;
  84:	81 e0       	ldi	r24, 0x01	; 1
  86:	90 e0       	ldi	r25, 0x00	; 0
  88:	9e 83       	std	Y+6, r25	; 0x06
  8a:	8d 83       	std	Y+5, r24	; 0x05
  8c:	00 c0       	rjmp	.+0      	; 0x8e <CLCD_voidSendData+0x8e>
	else if (__tmp > 65535)
  8e:	6f 81       	ldd	r22, Y+7	; 0x07
  90:	78 85       	ldd	r23, Y+8	; 0x08
  92:	89 85       	ldd	r24, Y+9	; 0x09
  94:	9a 85       	ldd	r25, Y+10	; 0x0a
  96:	20 e0       	ldi	r18, 0x00	; 0
  98:	3f ef       	ldi	r19, 0xFF	; 255
  9a:	4f e7       	ldi	r20, 0x7F	; 127
  9c:	57 e4       	ldi	r21, 0x47	; 71
  9e:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
  a2:	18 16       	cp	r1, r24
  a4:	04 f4       	brge	.+0      	; 0xa6 <CLCD_voidSendData+0xa6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  a6:	6b 85       	ldd	r22, Y+11	; 0x0b
  a8:	7c 85       	ldd	r23, Y+12	; 0x0c
  aa:	8d 85       	ldd	r24, Y+13	; 0x0d
  ac:	9e 85       	ldd	r25, Y+14	; 0x0e
  ae:	20 e0       	ldi	r18, 0x00	; 0
  b0:	30 e0       	ldi	r19, 0x00	; 0
  b2:	40 e2       	ldi	r20, 0x20	; 32
  b4:	51 e4       	ldi	r21, 0x41	; 65
  b6:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
  ba:	dc 01       	movw	r26, r24
  bc:	cb 01       	movw	r24, r22
  be:	bc 01       	movw	r22, r24
  c0:	cd 01       	movw	r24, r26
  c2:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
  c6:	dc 01       	movw	r26, r24
  c8:	cb 01       	movw	r24, r22
  ca:	9e 83       	std	Y+6, r25	; 0x06
  cc:	8d 83       	std	Y+5, r24	; 0x05
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <CLCD_voidSendData+0xd0>
  d0:	88 ec       	ldi	r24, 0xC8	; 200
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	9c 83       	std	Y+4, r25	; 0x04
  d6:	8b 83       	std	Y+3, r24	; 0x03
  d8:	8b 81       	ldd	r24, Y+3	; 0x03
  da:	9c 81       	ldd	r25, Y+4	; 0x04
  dc:	01 97       	sbiw	r24, 0x01	; 1
  de:	01 f4       	brne	.+0      	; 0xe0 <CLCD_voidSendData+0xe0>
  e0:	9c 83       	std	Y+4, r25	; 0x04
  e2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  e4:	8d 81       	ldd	r24, Y+5	; 0x05
  e6:	9e 81       	ldd	r25, Y+6	; 0x06
  e8:	01 97       	sbiw	r24, 0x01	; 1
  ea:	9e 83       	std	Y+6, r25	; 0x06
  ec:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  ee:	8d 81       	ldd	r24, Y+5	; 0x05
  f0:	9e 81       	ldd	r25, Y+6	; 0x06
  f2:	00 97       	sbiw	r24, 0x00	; 0
  f4:	01 f4       	brne	.+0      	; 0xf6 <CLCD_voidSendData+0xf6>
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <CLCD_voidSendData+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
  f8:	6f 81       	ldd	r22, Y+7	; 0x07
  fa:	78 85       	ldd	r23, Y+8	; 0x08
  fc:	89 85       	ldd	r24, Y+9	; 0x09
  fe:	9a 85       	ldd	r25, Y+10	; 0x0a
 100:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
 104:	dc 01       	movw	r26, r24
 106:	cb 01       	movw	r24, r22
 108:	9e 83       	std	Y+6, r25	; 0x06
 10a:	8d 83       	std	Y+5, r24	; 0x05
 10c:	8d 81       	ldd	r24, Y+5	; 0x05
 10e:	9e 81       	ldd	r25, Y+6	; 0x06
 110:	9a 83       	std	Y+2, r25	; 0x02
 112:	89 83       	std	Y+1, r24	; 0x01
 114:	89 81       	ldd	r24, Y+1	; 0x01
 116:	9a 81       	ldd	r25, Y+2	; 0x02
 118:	01 97       	sbiw	r24, 0x01	; 1
 11a:	01 f4       	brne	.+0      	; 0x11c <CLCD_voidSendData+0x11c>
 11c:	9a 83       	std	Y+2, r25	; 0x02
 11e:	89 83       	std	Y+1, r24	; 0x01
_delay_ms(2);
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_LOW);
 120:	83 e0       	ldi	r24, 0x03	; 3
 122:	62 e0       	ldi	r22, 0x02	; 2
 124:	40 e0       	ldi	r20, 0x00	; 0
 126:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendData>
}
 12a:	2f 96       	adiw	r28, 0x0f	; 15
 12c:	0f b6       	in	r0, 0x3f	; 63
 12e:	f8 94       	cli
 130:	de bf       	out	0x3e, r29	; 62
 132:	0f be       	out	0x3f, r0	; 63
 134:	cd bf       	out	0x3d, r28	; 61
 136:	cf 91       	pop	r28
 138:	df 91       	pop	r29
 13a:	08 95       	ret

Disassembly of section .text.CLCD_voidSendString:

00000000 <CLCD_voidSendString>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/CLCD_interface.h"
#include "../../../MCAL/DIO/inc/DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <CLCD_voidSendString+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	00 c0       	rjmp	.+0      	; 0x14 <CLCD_voidSendString+0x14>
  14:	89 81       	ldd	r24, Y+1	; 0x01
	/*Setting RS pin to low*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	9b 81       	ldd	r25, Y+3	; 0x03
  1e:	fc 01       	movw	r30, r24
/*Setting RW pin low for write*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
  20:	e2 0f       	add	r30, r18
  22:	f3 1f       	adc	r31, r19
  24:	80 81       	ld	r24, Z
  26:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidSendString>

/*Set command data pins*/
DIO_SetPortVal(CLCD_DATA_PORT,copy_u8Command);
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	8f 5f       	subi	r24, 0xFF	; 255
  2e:	89 83       	std	Y+1, r24	; 0x01
  30:	89 81       	ldd	r24, Y+1	; 0x01

/*Send Enable pulse*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
  32:	28 2f       	mov	r18, r24
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	8a 81       	ldd	r24, Y+2	; 0x02
  38:	9b 81       	ldd	r25, Y+3	; 0x03
  3a:	fc 01       	movw	r30, r24
  3c:	e2 0f       	add	r30, r18
  3e:	f3 1f       	adc	r31, r19
  40:	80 81       	ld	r24, Z
  42:	88 23       	and	r24, r24
  44:	01 f4       	brne	.+0      	; 0x46 <CLCD_voidSendString+0x46>
  46:	0f 90       	pop	r0
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  4c:	cf 91       	pop	r28
  4e:	df 91       	pop	r29
  50:	08 95       	ret

Disassembly of section .text.CLCD_voidGoToXY:

00000000 <CLCD_voidGoToXY>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/CLCD_interface.h"
#include "../../../MCAL/DIO/inc/DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <CLCD_voidGoToXY+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
   e:	6b 83       	std	Y+3, r22	; 0x03
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	88 23       	and	r24, r24
  14:	01 f4       	brne	.+0      	; 0x16 <CLCD_voidGoToXY+0x16>
	/*Setting RS pin to low*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
  16:	8b 81       	ldd	r24, Y+3	; 0x03
  18:	89 83       	std	Y+1, r24	; 0x01
  1a:	00 c0       	rjmp	.+0      	; 0x1c <CLCD_voidGoToXY+0x1c>
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	81 30       	cpi	r24, 0x01	; 1
/*Setting RW pin low for write*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
  20:	01 f4       	brne	.+0      	; 0x22 <CLCD_voidGoToXY+0x22>
  22:	8b 81       	ldd	r24, Y+3	; 0x03
  24:	80 5c       	subi	r24, 0xC0	; 192
  26:	89 83       	std	Y+1, r24	; 0x01
  28:	89 81       	ldd	r24, Y+1	; 0x01

/*Set command data pins*/
DIO_SetPortVal(CLCD_DATA_PORT,copy_u8Command);
  2a:	80 68       	ori	r24, 0x80	; 128
  2c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidGoToXY>
  30:	0f 90       	pop	r0

/*Send Enable pulse*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
  32:	0f 90       	pop	r0
  34:	0f 90       	pop	r0
  36:	cf 91       	pop	r28
  38:	df 91       	pop	r29
  3a:	08 95       	ret

Disassembly of section .text.CLCD_voidWriteNumber:

00000000 <CLCD_voidWriteNumber>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/CLCD_interface.h"
#include "../../../MCAL/DIO/inc/DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	df 93       	push	r29
   6:	cf 93       	push	r28
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	60 97       	sbiw	r28, 0x10	; 16
   e:	0f b6       	in	r0, 0x3f	; 63
  10:	f8 94       	cli
  12:	de bf       	out	0x3e, r29	; 62
  14:	0f be       	out	0x3f, r0	; 63
	/*Setting RS pin to low*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
  16:	cd bf       	out	0x3d, r28	; 61
  18:	6d 87       	std	Y+13, r22	; 0x0d
  1a:	7e 87       	std	Y+14, r23	; 0x0e
  1c:	8f 87       	std	Y+15, r24	; 0x0f
  1e:	98 8b       	std	Y+16, r25	; 0x10
/*Setting RW pin low for write*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
  20:	8d 85       	ldd	r24, Y+13	; 0x0d
  22:	9e 85       	ldd	r25, Y+14	; 0x0e
  24:	af 85       	ldd	r26, Y+15	; 0x0f
  26:	b8 89       	ldd	r27, Y+16	; 0x10
  28:	bb 23       	and	r27, r27

/*Set command data pins*/
DIO_SetPortVal(CLCD_DATA_PORT,copy_u8Command);
  2a:	04 f4       	brge	.+0      	; 0x2c <CLCD_voidWriteNumber+0x2c>
  2c:	8d e2       	ldi	r24, 0x2D	; 45
  2e:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteNumber>

/*Send Enable pulse*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
  32:	8d 85       	ldd	r24, Y+13	; 0x0d
  34:	9e 85       	ldd	r25, Y+14	; 0x0e
  36:	af 85       	ldd	r26, Y+15	; 0x0f
  38:	b8 89       	ldd	r27, Y+16	; 0x10
  3a:	b0 95       	com	r27
  3c:	a0 95       	com	r26
  3e:	90 95       	com	r25
  40:	81 95       	neg	r24
  42:	9f 4f       	sbci	r25, 0xFF	; 255
  44:	af 4f       	sbci	r26, 0xFF	; 255
  46:	bf 4f       	sbci	r27, 0xFF	; 255
  48:	8d 87       	std	Y+13, r24	; 0x0d
  4a:	9e 87       	std	Y+14, r25	; 0x0e
  4c:	af 87       	std	Y+15, r26	; 0x0f
  4e:	b8 8b       	std	Y+16, r27	; 0x10
  50:	8d 85       	ldd	r24, Y+13	; 0x0d
  52:	9e 85       	ldd	r25, Y+14	; 0x0e
  54:	af 85       	ldd	r26, Y+15	; 0x0f
  56:	b8 89       	ldd	r27, Y+16	; 0x10
  58:	00 97       	sbiw	r24, 0x00	; 0
  5a:	a1 05       	cpc	r26, r1
  5c:	b1 05       	cpc	r27, r1
  5e:	01 f4       	brne	.+0      	; 0x60 <CLCD_voidWriteNumber+0x60>
  60:	80 e3       	ldi	r24, 0x30	; 48
  62:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteNumber>
  66:	00 c0       	rjmp	.+0      	; 0x68 <CLCD_voidWriteNumber+0x68>
  68:	1a 82       	std	Y+2, r1	; 0x02
  6a:	00 c0       	rjmp	.+0      	; 0x6c <CLCD_voidWriteNumber+0x6c>
	if (__tmp < 1.0)
  6c:	8a 81       	ldd	r24, Y+2	; 0x02
  6e:	08 2f       	mov	r16, r24
  70:	10 e0       	ldi	r17, 0x00	; 0
  72:	8d 85       	ldd	r24, Y+13	; 0x0d
  74:	9e 85       	ldd	r25, Y+14	; 0x0e
  76:	af 85       	ldd	r26, Y+15	; 0x0f
  78:	b8 89       	ldd	r27, Y+16	; 0x10
  7a:	2a e0       	ldi	r18, 0x0A	; 10
  7c:	30 e0       	ldi	r19, 0x00	; 0
  7e:	40 e0       	ldi	r20, 0x00	; 0
  80:	50 e0       	ldi	r21, 0x00	; 0
  82:	bc 01       	movw	r22, r24
		__ticks = 1;
  84:	cd 01       	movw	r24, r26
  86:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteNumber>
  8a:	dc 01       	movw	r26, r24
  8c:	cb 01       	movw	r24, r22
	else if (__tmp > 65535)
  8e:	28 2f       	mov	r18, r24
  90:	20 5d       	subi	r18, 0xD0	; 208
  92:	ce 01       	movw	r24, r28
  94:	03 96       	adiw	r24, 0x03	; 3
  96:	fc 01       	movw	r30, r24
  98:	e0 0f       	add	r30, r16
  9a:	f1 1f       	adc	r31, r17
  9c:	20 83       	st	Z, r18
  9e:	8a 81       	ldd	r24, Y+2	; 0x02
  a0:	8f 5f       	subi	r24, 0xFF	; 255
  a2:	8a 83       	std	Y+2, r24	; 0x02
  a4:	8d 85       	ldd	r24, Y+13	; 0x0d
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  a6:	9e 85       	ldd	r25, Y+14	; 0x0e
  a8:	af 85       	ldd	r26, Y+15	; 0x0f
  aa:	b8 89       	ldd	r27, Y+16	; 0x10
  ac:	2a e0       	ldi	r18, 0x0A	; 10
  ae:	30 e0       	ldi	r19, 0x00	; 0
  b0:	40 e0       	ldi	r20, 0x00	; 0
  b2:	50 e0       	ldi	r21, 0x00	; 0
  b4:	bc 01       	movw	r22, r24
  b6:	cd 01       	movw	r24, r26
  b8:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteNumber>
  bc:	da 01       	movw	r26, r20
  be:	c9 01       	movw	r24, r18
  c0:	8d 87       	std	Y+13, r24	; 0x0d
  c2:	9e 87       	std	Y+14, r25	; 0x0e
  c4:	af 87       	std	Y+15, r26	; 0x0f
  c6:	b8 8b       	std	Y+16, r27	; 0x10
  c8:	8d 85       	ldd	r24, Y+13	; 0x0d
  ca:	9e 85       	ldd	r25, Y+14	; 0x0e
  cc:	af 85       	ldd	r26, Y+15	; 0x0f
  ce:	b8 89       	ldd	r27, Y+16	; 0x10
  d0:	18 16       	cp	r1, r24
  d2:	19 06       	cpc	r1, r25
  d4:	1a 06       	cpc	r1, r26
  d6:	1b 06       	cpc	r1, r27
  d8:	04 f0       	brlt	.+0      	; 0xda <CLCD_voidWriteNumber+0xda>
  da:	8a 81       	ldd	r24, Y+2	; 0x02
  dc:	89 83       	std	Y+1, r24	; 0x01
  de:	00 c0       	rjmp	.+0      	; 0xe0 <CLCD_voidWriteNumber+0xe0>
  e0:	89 81       	ldd	r24, Y+1	; 0x01
  e2:	88 2f       	mov	r24, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	9c 01       	movw	r18, r24
  e8:	21 50       	subi	r18, 0x01	; 1
  ea:	30 40       	sbci	r19, 0x00	; 0
  ec:	ce 01       	movw	r24, r28
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  ee:	03 96       	adiw	r24, 0x03	; 3
  f0:	fc 01       	movw	r30, r24
  f2:	e2 0f       	add	r30, r18
  f4:	f3 1f       	adc	r31, r19
  f6:	80 81       	ld	r24, Z
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
  f8:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteNumber>
  fc:	89 81       	ldd	r24, Y+1	; 0x01
  fe:	81 50       	subi	r24, 0x01	; 1
 100:	89 83       	std	Y+1, r24	; 0x01
 102:	89 81       	ldd	r24, Y+1	; 0x01
 104:	88 23       	and	r24, r24
 106:	01 f4       	brne	.+0      	; 0x108 <CLCD_voidWriteNumber+0x108>
 108:	60 96       	adiw	r28, 0x10	; 16
 10a:	0f b6       	in	r0, 0x3f	; 63
 10c:	f8 94       	cli
 10e:	de bf       	out	0x3e, r29	; 62
 110:	0f be       	out	0x3f, r0	; 63
 112:	cd bf       	out	0x3d, r28	; 61
 114:	cf 91       	pop	r28
 116:	df 91       	pop	r29
 118:	1f 91       	pop	r17
 11a:	0f 91       	pop	r16
 11c:	08 95       	ret

Disassembly of section .text.CLCD_voidWriteSpecialChar:

00000000 <CLCD_voidWriteSpecialChar>:
#include "../../../LIB/BIT_MATH.h"
#include "../inc/CLCD_interface.h"
#include "../../../MCAL/DIO/inc/DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	27 97       	sbiw	r28, 0x07	; 7
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9c 83       	std	Y+4, r25	; 0x04
	/*Setting RS pin to low*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
  16:	8b 83       	std	Y+3, r24	; 0x03
  18:	6d 83       	std	Y+5, r22	; 0x05
  1a:	4e 83       	std	Y+6, r20	; 0x06
  1c:	2f 83       	std	Y+7, r18	; 0x07
  1e:	1a 82       	std	Y+2, r1	; 0x02
/*Setting RW pin low for write*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
  20:	8d 81       	ldd	r24, Y+5	; 0x05
  22:	88 2f       	mov	r24, r24
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	88 0f       	add	r24, r24
  28:	99 1f       	adc	r25, r25

/*Set command data pins*/
DIO_SetPortVal(CLCD_DATA_PORT,copy_u8Command);
  2a:	88 0f       	add	r24, r24
  2c:	99 1f       	adc	r25, r25
  2e:	88 0f       	add	r24, r24
  30:	99 1f       	adc	r25, r25

/*Send Enable pulse*/
DIO_SetPinVal(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
  32:	8a 83       	std	Y+2, r24	; 0x02
  34:	8a 81       	ldd	r24, Y+2	; 0x02
  36:	80 64       	ori	r24, 0x40	; 64
  38:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteSpecialChar>
  3c:	19 82       	std	Y+1, r1	; 0x01
  3e:	00 c0       	rjmp	.+0      	; 0x40 <CLCD_voidWriteSpecialChar+0x40>
  40:	89 81       	ldd	r24, Y+1	; 0x01
  42:	28 2f       	mov	r18, r24
  44:	30 e0       	ldi	r19, 0x00	; 0
  46:	8b 81       	ldd	r24, Y+3	; 0x03
  48:	9c 81       	ldd	r25, Y+4	; 0x04
  4a:	fc 01       	movw	r30, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  4c:	e2 0f       	add	r30, r18
  4e:	f3 1f       	adc	r31, r19
  50:	80 81       	ld	r24, Z
  52:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteSpecialChar>
  56:	89 81       	ldd	r24, Y+1	; 0x01
  58:	8f 5f       	subi	r24, 0xFF	; 255
  5a:	89 83       	std	Y+1, r24	; 0x01
  5c:	89 81       	ldd	r24, Y+1	; 0x01
  5e:	88 30       	cpi	r24, 0x08	; 8
  60:	00 f0       	brcs	.+0      	; 0x62 <CLCD_voidWriteSpecialChar+0x62>
  62:	8e 81       	ldd	r24, Y+6	; 0x06
  64:	6f 81       	ldd	r22, Y+7	; 0x07
  66:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteSpecialChar>
  6a:	8d 81       	ldd	r24, Y+5	; 0x05
	if (__tmp < 1.0)
  6c:	0e 94 00 00 	call	0	; 0x0 <CLCD_voidWriteSpecialChar>
  70:	27 96       	adiw	r28, 0x07	; 7
  72:	0f b6       	in	r0, 0x3f	; 63
  74:	f8 94       	cli
  76:	de bf       	out	0x3e, r29	; 62
  78:	0f be       	out	0x3f, r0	; 63
  7a:	cd bf       	out	0x3d, r28	; 61
  7c:	cf 91       	pop	r28
  7e:	df 91       	pop	r29
  80:	08 95       	ret

main.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000234  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000492  00000000  00000000  00000268  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.main    00000022  00000000  00000000  000006fa  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.main:

00000000 <main>:
#include "../BSW/MCAL/DIO/inc/DIO_interface.h"



int main()
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	PORT_voidInit();
   8:	0e 94 00 00 	call	0	; 0x0 <main>

	DIO_SetPinVal(DIO_PORTA,DIO_Pin0,DIO_HIGH);
   c:	80 e0       	ldi	r24, 0x00	; 0
   e:	60 e0       	ldi	r22, 0x00	; 0
  10:	41 e0       	ldi	r20, 0x01	; 1
  12:	0e 94 00 00 	call	0	; 0x0 <main>
	DIO_SetPinVal(DIO_PORTA,DIO_Pin1,DIO_HIGH);
  16:	80 e0       	ldi	r24, 0x00	; 0
  18:	61 e0       	ldi	r22, 0x01	; 1
  1a:	41 e0       	ldi	r20, 0x01	; 1
  1c:	0e 94 00 00 	call	0	; 0x0 <main>
  20:	00 c0       	rjmp	.+0      	; 0x22 <__zero_reg__+0x21>
